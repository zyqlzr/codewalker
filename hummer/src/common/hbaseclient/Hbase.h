/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Hbase_H
#define Hbase_H

#include <TProcessor.h>
#include "hbase_types.h"

namespace apache { namespace hadoop { namespace hbase { namespace thrift {

class HbaseIf {
 public:
  virtual ~HbaseIf() {}
  virtual void enableTable(const Bytes& tableName) = 0;
  virtual void disableTable(const Bytes& tableName) = 0;
  virtual bool isTableEnabled(const Bytes& tableName) = 0;
  virtual void compact(const Bytes& tableNameOrRegionName) = 0;
  virtual void majorCompact(const Bytes& tableNameOrRegionName) = 0;
  virtual void getTableNames(std::vector<Text> & _return) = 0;
  virtual void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName) = 0;
  virtual void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName) = 0;
  virtual void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies) = 0;
  virtual void deleteTable(const Text& tableName) = 0;
  virtual void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column) = 0;
  virtual void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions) = 0;
  virtual void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions) = 0;
  virtual void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row) = 0;
  virtual void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns) = 0;
  virtual void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp) = 0;
  virtual void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp) = 0;
  virtual void getRowWithColumnPrefix(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const Text& prefix) = 0;
  virtual void getRowWithColumnPrefixTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const Text& prefix, const int64_t timestamp) = 0;
  virtual void getRowWithMultipleColumnPrefixes(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes) = 0;
  virtual void getRowWithMultipleColumnPrefixesTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp) = 0;
  virtual void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows) = 0;
  virtual void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp) = 0;
  virtual void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & families) = 0;
  virtual void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & families, const int64_t timestamp) = 0;
  virtual void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes) = 0;
  virtual void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes) = 0;
  virtual void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual bool checkAndMutateRow(const Text& tableName, const Text& row, const Text& columnCheck, const Text& valueCheck, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes) = 0;
  virtual bool checkAndMutateRowTs(const Text& tableName, const Text& row, const Text& columnCheck, const Text& valueCheck, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value) = 0;
  virtual void deleteAll(const Text& tableName, const Text& row, const Text& column) = 0;
  virtual void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp) = 0;
  virtual void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) = 0;
  virtual void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp) = 0;
  virtual void mutateRowsAsync(const Text& tableName, const std::vector<BatchMutation> & rowBatches) = 0;
  virtual void mutateRowsTsAsync(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp) = 0;
  virtual int64_t taoAssocPut(const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t id2, const int64_t id1Type, const int64_t id2Type, const int64_t timestamp, const AssocVisibility::type visibility, const bool update_count, const int64_t dataVersion, const Text& data, const Text& wormhole_comment) = 0;
  virtual int64_t taoAssocDelete(const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t id2, const AssocVisibility::type visibility, const bool update_count, const Text& wormhole_comment) = 0;
  virtual void taoAssocRangeGet(std::vector<TaoAssocGetResult> & _return, const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t start_time, const int64_t end_time, const int64_t offset, const int64_t limit) = 0;
  virtual void taoAssocGet(std::vector<TaoAssocGetResult> & _return, const Text& tableName, const int64_t assocType, const int64_t id1, const std::vector<int64_t> & id2s) = 0;
  virtual int64_t taoAssocCount(const Text& tableName, const int64_t assocType, const int64_t id1) = 0;
  virtual ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan) = 0;
  virtual ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns) = 0;
  virtual ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp) = 0;
  virtual ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns) = 0;
  virtual ScannerID scannerOpenWithPrefixTs(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const int64_t timestamp) = 0;
  virtual ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns) = 0;
  virtual ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp) = 0;
  virtual ScannerID scannerOpenWithColumnPrefix(const Text& tableName, const Text& ColumnPrefix) = 0;
  virtual ScannerID scannerOpenWithColumnPrefixTs(const Text& tableName, const Text& ColumnPrefix, const int64_t timestamp) = 0;
  virtual ScannerID scannerOpenWithStopAndColumnPrefix(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& ColumnPrefix) = 0;
  virtual ScannerID scannerOpenWithStopAndColumnPrefixTs(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& ColumnPrefix, const int64_t timestamp) = 0;
  virtual ScannerID scannerOpenWithMultipleColumnPrefixes(const Text& tableName, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes) = 0;
  virtual ScannerID scannerOpenWithMultipleColumnPrefixesTs(const Text& tableName, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp) = 0;
  virtual ScannerID scannerOpenWithStopAndMultipleColumnPrefixes(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes) = 0;
  virtual ScannerID scannerOpenWithStopAndMultipleColumnPrefixesTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp) = 0;
  virtual void scannerGet(std::vector<TRowResult> & _return, const ScannerID id) = 0;
  virtual void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows) = 0;
  virtual void scannerClose(const ScannerID id) = 0;
  virtual void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family) = 0;
  virtual void getRegionInfo(TRegionInfo& _return, const Text& row) = 0;
  virtual ScannerID scannerOpenWithFilterString(const Text& tableName, const Text& filterString) = 0;
  virtual ScannerID scannerOpenWithFilterStringTs(const Text& tableName, const Text& filterString, const int64_t timestamp) = 0;
  virtual ScannerID scannerOpenWithStopAndFilterString(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& filterString) = 0;
  virtual ScannerID scannerOpenWithStopAndFilterStringTs(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& filterString, const int64_t timestamp) = 0;
};

class HbaseIfFactory {
 public:
  typedef HbaseIf Handler;

  virtual ~HbaseIfFactory() {}

  virtual HbaseIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(HbaseIf* /* handler */) = 0;
};

class HbaseIfSingletonFactory : virtual public HbaseIfFactory {
 public:
  HbaseIfSingletonFactory(const boost::shared_ptr<HbaseIf>& iface) : iface_(iface) {}
  virtual ~HbaseIfSingletonFactory() {}

  virtual HbaseIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(HbaseIf* /* handler */) {}

 protected:
  boost::shared_ptr<HbaseIf> iface_;
};

class HbaseNull : virtual public HbaseIf {
 public:
  virtual ~HbaseNull() {}
  void enableTable(const Bytes& /* tableName */) {
    return;
  }
  void disableTable(const Bytes& /* tableName */) {
    return;
  }
  bool isTableEnabled(const Bytes& /* tableName */) {
    bool _return = false;
    return _return;
  }
  void compact(const Bytes& /* tableNameOrRegionName */) {
    return;
  }
  void majorCompact(const Bytes& /* tableNameOrRegionName */) {
    return;
  }
  void getTableNames(std::vector<Text> & /* _return */) {
    return;
  }
  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & /* _return */, const Text& /* tableName */) {
    return;
  }
  void getTableRegions(std::vector<TRegionInfo> & /* _return */, const Text& /* tableName */) {
    return;
  }
  void createTable(const Text& /* tableName */, const std::vector<ColumnDescriptor> & /* columnFamilies */) {
    return;
  }
  void deleteTable(const Text& /* tableName */) {
    return;
  }
  void get(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */) {
    return;
  }
  void getVer(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int32_t /* numVersions */) {
    return;
  }
  void getVerTs(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* timestamp */, const int32_t /* numVersions */) {
    return;
  }
  void getRow(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */) {
    return;
  }
  void getRowWithColumns(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::vector<Text> & /* columns */) {
    return;
  }
  void getRowTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const int64_t /* timestamp */) {
    return;
  }
  void getRowWithColumnsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */) {
    return;
  }
  void getRowWithColumnPrefix(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* prefix */) {
    return;
  }
  void getRowWithColumnPrefixTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* prefix */, const int64_t /* timestamp */) {
    return;
  }
  void getRowWithMultipleColumnPrefixes(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::vector<Text> & /* families */, const std::vector<Text> & /* columnPrefixes */) {
    return;
  }
  void getRowWithMultipleColumnPrefixesTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::vector<Text> & /* families */, const std::vector<Text> & /* columnPrefixes */, const int64_t /* timestamp */) {
    return;
  }
  void getRows(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */) {
    return;
  }
  void getRowsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const int64_t /* timestamp */) {
    return;
  }
  void getRowsWithColumns(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const std::vector<Text> & /* families */) {
    return;
  }
  void getRowsWithColumnsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const std::vector<Text> & /* families */, const int64_t /* timestamp */) {
    return;
  }
  void mutateRow(const Text& /* tableName */, const Text& /* row */, const std::vector<Mutation> & /* mutations */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRowTs(const Text& /* tableName */, const Text& /* row */, const std::vector<Mutation> & /* mutations */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRows(const Text& /* tableName */, const std::vector<BatchMutation> & /* rowBatches */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRowsTs(const Text& /* tableName */, const std::vector<BatchMutation> & /* rowBatches */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  bool checkAndMutateRow(const Text& /* tableName */, const Text& /* row */, const Text& /* columnCheck */, const Text& /* valueCheck */, const std::vector<Mutation> & /* mutations */, const std::map<Text, Text> & /* attributes */) {
    bool _return = false;
    return _return;
  }
  bool checkAndMutateRowTs(const Text& /* tableName */, const Text& /* row */, const Text& /* columnCheck */, const Text& /* valueCheck */, const std::vector<Mutation> & /* mutations */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    bool _return = false;
    return _return;
  }
  int64_t atomicIncrement(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* value */) {
    int64_t _return = 0;
    return _return;
  }
  void deleteAll(const Text& /* tableName */, const Text& /* row */, const Text& /* column */) {
    return;
  }
  void deleteAllTs(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* timestamp */) {
    return;
  }
  void deleteAllRow(const Text& /* tableName */, const Text& /* row */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void deleteAllRowTs(const Text& /* tableName */, const Text& /* row */, const int64_t /* timestamp */) {
    return;
  }
  void mutateRowsAsync(const Text& /* tableName */, const std::vector<BatchMutation> & /* rowBatches */) {
    return;
  }
  void mutateRowsTsAsync(const Text& /* tableName */, const std::vector<BatchMutation> & /* rowBatches */, const int64_t /* timestamp */) {
    return;
  }
  int64_t taoAssocPut(const Text& /* tableName */, const int64_t /* assocType */, const int64_t /* id1 */, const int64_t /* id2 */, const int64_t /* id1Type */, const int64_t /* id2Type */, const int64_t /* timestamp */, const AssocVisibility::type /* visibility */, const bool /* update_count */, const int64_t /* dataVersion */, const Text& /* data */, const Text& /* wormhole_comment */) {
    int64_t _return = 0;
    return _return;
  }
  int64_t taoAssocDelete(const Text& /* tableName */, const int64_t /* assocType */, const int64_t /* id1 */, const int64_t /* id2 */, const AssocVisibility::type /* visibility */, const bool /* update_count */, const Text& /* wormhole_comment */) {
    int64_t _return = 0;
    return _return;
  }
  void taoAssocRangeGet(std::vector<TaoAssocGetResult> & /* _return */, const Text& /* tableName */, const int64_t /* assocType */, const int64_t /* id1 */, const int64_t /* start_time */, const int64_t /* end_time */, const int64_t /* offset */, const int64_t /* limit */) {
    return;
  }
  void taoAssocGet(std::vector<TaoAssocGetResult> & /* _return */, const Text& /* tableName */, const int64_t /* assocType */, const int64_t /* id1 */, const std::vector<int64_t> & /* id2s */) {
    return;
  }
  int64_t taoAssocCount(const Text& /* tableName */, const int64_t /* assocType */, const int64_t /* id1 */) {
    int64_t _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithScan(const Text& /* tableName */, const TScan& /* scan */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpen(const Text& /* tableName */, const Text& /* startRow */, const std::vector<Text> & /* columns */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenTs(const Text& /* tableName */, const Text& /* startRow */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithPrefix(const Text& /* tableName */, const Text& /* startAndPrefix */, const std::vector<Text> & /* columns */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithPrefixTs(const Text& /* tableName */, const Text& /* startAndPrefix */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStop(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const std::vector<Text> & /* columns */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStopTs(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithColumnPrefix(const Text& /* tableName */, const Text& /* ColumnPrefix */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithColumnPrefixTs(const Text& /* tableName */, const Text& /* ColumnPrefix */, const int64_t /* timestamp */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStopAndColumnPrefix(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const Text& /* ColumnPrefix */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStopAndColumnPrefixTs(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const Text& /* ColumnPrefix */, const int64_t /* timestamp */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithMultipleColumnPrefixes(const Text& /* tableName */, const std::vector<Text> & /* families */, const std::vector<Text> & /* columnPrefixes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithMultipleColumnPrefixesTs(const Text& /* tableName */, const std::vector<Text> & /* families */, const std::vector<Text> & /* columnPrefixes */, const int64_t /* timestamp */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStopAndMultipleColumnPrefixes(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const std::vector<Text> & /* families */, const std::vector<Text> & /* columnPrefixes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStopAndMultipleColumnPrefixesTs(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const std::vector<Text> & /* families */, const std::vector<Text> & /* columnPrefixes */, const int64_t /* timestamp */) {
    ScannerID _return = 0;
    return _return;
  }
  void scannerGet(std::vector<TRowResult> & /* _return */, const ScannerID /* id */) {
    return;
  }
  void scannerGetList(std::vector<TRowResult> & /* _return */, const ScannerID /* id */, const int32_t /* nbRows */) {
    return;
  }
  void scannerClose(const ScannerID /* id */) {
    return;
  }
  void getRowOrBefore(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* family */) {
    return;
  }
  void getRegionInfo(TRegionInfo& /* _return */, const Text& /* row */) {
    return;
  }
  ScannerID scannerOpenWithFilterString(const Text& /* tableName */, const Text& /* filterString */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithFilterStringTs(const Text& /* tableName */, const Text& /* filterString */, const int64_t /* timestamp */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStopAndFilterString(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const Text& /* filterString */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStopAndFilterStringTs(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const Text& /* filterString */, const int64_t /* timestamp */) {
    ScannerID _return = 0;
    return _return;
  }
};

typedef struct _Hbase_enableTable_args__isset {
  _Hbase_enableTable_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_enableTable_args__isset;

class Hbase_enableTable_args {
 public:

  Hbase_enableTable_args() : tableName("") {
  }

  virtual ~Hbase_enableTable_args() throw() {}

  Bytes tableName;

  _Hbase_enableTable_args__isset __isset;

  void __set_tableName(const Bytes& val) {
    tableName = val;
  }

  bool operator == (const Hbase_enableTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_enableTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_enableTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_enableTable_pargs {
 public:


  virtual ~Hbase_enableTable_pargs() throw() {}

  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_enableTable_result__isset {
  _Hbase_enableTable_result__isset() : io(false) {}
  bool io;
} _Hbase_enableTable_result__isset;

class Hbase_enableTable_result {
 public:

  Hbase_enableTable_result() {
  }

  virtual ~Hbase_enableTable_result() throw() {}

  IOError io;

  _Hbase_enableTable_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_enableTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_enableTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_enableTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_enableTable_presult__isset {
  _Hbase_enableTable_presult__isset() : io(false) {}
  bool io;
} _Hbase_enableTable_presult__isset;

class Hbase_enableTable_presult {
 public:


  virtual ~Hbase_enableTable_presult() throw() {}

  IOError io;

  _Hbase_enableTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_disableTable_args__isset {
  _Hbase_disableTable_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_disableTable_args__isset;

class Hbase_disableTable_args {
 public:

  Hbase_disableTable_args() : tableName("") {
  }

  virtual ~Hbase_disableTable_args() throw() {}

  Bytes tableName;

  _Hbase_disableTable_args__isset __isset;

  void __set_tableName(const Bytes& val) {
    tableName = val;
  }

  bool operator == (const Hbase_disableTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_disableTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_disableTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_disableTable_pargs {
 public:


  virtual ~Hbase_disableTable_pargs() throw() {}

  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_disableTable_result__isset {
  _Hbase_disableTable_result__isset() : io(false) {}
  bool io;
} _Hbase_disableTable_result__isset;

class Hbase_disableTable_result {
 public:

  Hbase_disableTable_result() {
  }

  virtual ~Hbase_disableTable_result() throw() {}

  IOError io;

  _Hbase_disableTable_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_disableTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_disableTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_disableTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_disableTable_presult__isset {
  _Hbase_disableTable_presult__isset() : io(false) {}
  bool io;
} _Hbase_disableTable_presult__isset;

class Hbase_disableTable_presult {
 public:


  virtual ~Hbase_disableTable_presult() throw() {}

  IOError io;

  _Hbase_disableTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_isTableEnabled_args__isset {
  _Hbase_isTableEnabled_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_isTableEnabled_args__isset;

class Hbase_isTableEnabled_args {
 public:

  Hbase_isTableEnabled_args() : tableName("") {
  }

  virtual ~Hbase_isTableEnabled_args() throw() {}

  Bytes tableName;

  _Hbase_isTableEnabled_args__isset __isset;

  void __set_tableName(const Bytes& val) {
    tableName = val;
  }

  bool operator == (const Hbase_isTableEnabled_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_isTableEnabled_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_isTableEnabled_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_isTableEnabled_pargs {
 public:


  virtual ~Hbase_isTableEnabled_pargs() throw() {}

  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_isTableEnabled_result__isset {
  _Hbase_isTableEnabled_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_isTableEnabled_result__isset;

class Hbase_isTableEnabled_result {
 public:

  Hbase_isTableEnabled_result() : success(0) {
  }

  virtual ~Hbase_isTableEnabled_result() throw() {}

  bool success;
  IOError io;

  _Hbase_isTableEnabled_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_isTableEnabled_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_isTableEnabled_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_isTableEnabled_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_isTableEnabled_presult__isset {
  _Hbase_isTableEnabled_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_isTableEnabled_presult__isset;

class Hbase_isTableEnabled_presult {
 public:


  virtual ~Hbase_isTableEnabled_presult() throw() {}

  bool* success;
  IOError io;

  _Hbase_isTableEnabled_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_compact_args__isset {
  _Hbase_compact_args__isset() : tableNameOrRegionName(false) {}
  bool tableNameOrRegionName;
} _Hbase_compact_args__isset;

class Hbase_compact_args {
 public:

  Hbase_compact_args() : tableNameOrRegionName("") {
  }

  virtual ~Hbase_compact_args() throw() {}

  Bytes tableNameOrRegionName;

  _Hbase_compact_args__isset __isset;

  void __set_tableNameOrRegionName(const Bytes& val) {
    tableNameOrRegionName = val;
  }

  bool operator == (const Hbase_compact_args & rhs) const
  {
    if (!(tableNameOrRegionName == rhs.tableNameOrRegionName))
      return false;
    return true;
  }
  bool operator != (const Hbase_compact_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_compact_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_compact_pargs {
 public:


  virtual ~Hbase_compact_pargs() throw() {}

  const Bytes* tableNameOrRegionName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_compact_result__isset {
  _Hbase_compact_result__isset() : io(false) {}
  bool io;
} _Hbase_compact_result__isset;

class Hbase_compact_result {
 public:

  Hbase_compact_result() {
  }

  virtual ~Hbase_compact_result() throw() {}

  IOError io;

  _Hbase_compact_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_compact_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_compact_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_compact_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_compact_presult__isset {
  _Hbase_compact_presult__isset() : io(false) {}
  bool io;
} _Hbase_compact_presult__isset;

class Hbase_compact_presult {
 public:


  virtual ~Hbase_compact_presult() throw() {}

  IOError io;

  _Hbase_compact_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_majorCompact_args__isset {
  _Hbase_majorCompact_args__isset() : tableNameOrRegionName(false) {}
  bool tableNameOrRegionName;
} _Hbase_majorCompact_args__isset;

class Hbase_majorCompact_args {
 public:

  Hbase_majorCompact_args() : tableNameOrRegionName("") {
  }

  virtual ~Hbase_majorCompact_args() throw() {}

  Bytes tableNameOrRegionName;

  _Hbase_majorCompact_args__isset __isset;

  void __set_tableNameOrRegionName(const Bytes& val) {
    tableNameOrRegionName = val;
  }

  bool operator == (const Hbase_majorCompact_args & rhs) const
  {
    if (!(tableNameOrRegionName == rhs.tableNameOrRegionName))
      return false;
    return true;
  }
  bool operator != (const Hbase_majorCompact_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_majorCompact_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_majorCompact_pargs {
 public:


  virtual ~Hbase_majorCompact_pargs() throw() {}

  const Bytes* tableNameOrRegionName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_majorCompact_result__isset {
  _Hbase_majorCompact_result__isset() : io(false) {}
  bool io;
} _Hbase_majorCompact_result__isset;

class Hbase_majorCompact_result {
 public:

  Hbase_majorCompact_result() {
  }

  virtual ~Hbase_majorCompact_result() throw() {}

  IOError io;

  _Hbase_majorCompact_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_majorCompact_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_majorCompact_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_majorCompact_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_majorCompact_presult__isset {
  _Hbase_majorCompact_presult__isset() : io(false) {}
  bool io;
} _Hbase_majorCompact_presult__isset;

class Hbase_majorCompact_presult {
 public:


  virtual ~Hbase_majorCompact_presult() throw() {}

  IOError io;

  _Hbase_majorCompact_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Hbase_getTableNames_args {
 public:

  Hbase_getTableNames_args() {
  }

  virtual ~Hbase_getTableNames_args() throw() {}


  bool operator == (const Hbase_getTableNames_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Hbase_getTableNames_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableNames_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getTableNames_pargs {
 public:


  virtual ~Hbase_getTableNames_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getTableNames_result__isset {
  _Hbase_getTableNames_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getTableNames_result__isset;

class Hbase_getTableNames_result {
 public:

  Hbase_getTableNames_result() {
  }

  virtual ~Hbase_getTableNames_result() throw() {}

  std::vector<Text>  success;
  IOError io;

  _Hbase_getTableNames_result__isset __isset;

  void __set_success(const std::vector<Text> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getTableNames_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableNames_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableNames_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getTableNames_presult__isset {
  _Hbase_getTableNames_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getTableNames_presult__isset;

class Hbase_getTableNames_presult {
 public:


  virtual ~Hbase_getTableNames_presult() throw() {}

  std::vector<Text> * success;
  IOError io;

  _Hbase_getTableNames_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getColumnDescriptors_args__isset {
  _Hbase_getColumnDescriptors_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_getColumnDescriptors_args__isset;

class Hbase_getColumnDescriptors_args {
 public:

  Hbase_getColumnDescriptors_args() : tableName("") {
  }

  virtual ~Hbase_getColumnDescriptors_args() throw() {}

  Text tableName;

  _Hbase_getColumnDescriptors_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  bool operator == (const Hbase_getColumnDescriptors_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_getColumnDescriptors_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getColumnDescriptors_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getColumnDescriptors_pargs {
 public:


  virtual ~Hbase_getColumnDescriptors_pargs() throw() {}

  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getColumnDescriptors_result__isset {
  _Hbase_getColumnDescriptors_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getColumnDescriptors_result__isset;

class Hbase_getColumnDescriptors_result {
 public:

  Hbase_getColumnDescriptors_result() {
  }

  virtual ~Hbase_getColumnDescriptors_result() throw() {}

  std::map<Text, ColumnDescriptor>  success;
  IOError io;

  _Hbase_getColumnDescriptors_result__isset __isset;

  void __set_success(const std::map<Text, ColumnDescriptor> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getColumnDescriptors_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getColumnDescriptors_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getColumnDescriptors_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getColumnDescriptors_presult__isset {
  _Hbase_getColumnDescriptors_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getColumnDescriptors_presult__isset;

class Hbase_getColumnDescriptors_presult {
 public:


  virtual ~Hbase_getColumnDescriptors_presult() throw() {}

  std::map<Text, ColumnDescriptor> * success;
  IOError io;

  _Hbase_getColumnDescriptors_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getTableRegions_args__isset {
  _Hbase_getTableRegions_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_getTableRegions_args__isset;

class Hbase_getTableRegions_args {
 public:

  Hbase_getTableRegions_args() : tableName("") {
  }

  virtual ~Hbase_getTableRegions_args() throw() {}

  Text tableName;

  _Hbase_getTableRegions_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  bool operator == (const Hbase_getTableRegions_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableRegions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableRegions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getTableRegions_pargs {
 public:


  virtual ~Hbase_getTableRegions_pargs() throw() {}

  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getTableRegions_result__isset {
  _Hbase_getTableRegions_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getTableRegions_result__isset;

class Hbase_getTableRegions_result {
 public:

  Hbase_getTableRegions_result() {
  }

  virtual ~Hbase_getTableRegions_result() throw() {}

  std::vector<TRegionInfo>  success;
  IOError io;

  _Hbase_getTableRegions_result__isset __isset;

  void __set_success(const std::vector<TRegionInfo> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getTableRegions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableRegions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableRegions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getTableRegions_presult__isset {
  _Hbase_getTableRegions_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getTableRegions_presult__isset;

class Hbase_getTableRegions_presult {
 public:


  virtual ~Hbase_getTableRegions_presult() throw() {}

  std::vector<TRegionInfo> * success;
  IOError io;

  _Hbase_getTableRegions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_createTable_args__isset {
  _Hbase_createTable_args__isset() : tableName(false), columnFamilies(false) {}
  bool tableName;
  bool columnFamilies;
} _Hbase_createTable_args__isset;

class Hbase_createTable_args {
 public:

  Hbase_createTable_args() : tableName("") {
  }

  virtual ~Hbase_createTable_args() throw() {}

  Text tableName;
  std::vector<ColumnDescriptor>  columnFamilies;

  _Hbase_createTable_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_columnFamilies(const std::vector<ColumnDescriptor> & val) {
    columnFamilies = val;
  }

  bool operator == (const Hbase_createTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(columnFamilies == rhs.columnFamilies))
      return false;
    return true;
  }
  bool operator != (const Hbase_createTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_createTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_createTable_pargs {
 public:


  virtual ~Hbase_createTable_pargs() throw() {}

  const Text* tableName;
  const std::vector<ColumnDescriptor> * columnFamilies;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_createTable_result__isset {
  _Hbase_createTable_result__isset() : io(false), ia(false), exist(false) {}
  bool io;
  bool ia;
  bool exist;
} _Hbase_createTable_result__isset;

class Hbase_createTable_result {
 public:

  Hbase_createTable_result() {
  }

  virtual ~Hbase_createTable_result() throw() {}

  IOError io;
  IllegalArgument ia;
  AlreadyExists exist;

  _Hbase_createTable_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  void __set_exist(const AlreadyExists& val) {
    exist = val;
  }

  bool operator == (const Hbase_createTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    if (!(exist == rhs.exist))
      return false;
    return true;
  }
  bool operator != (const Hbase_createTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_createTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_createTable_presult__isset {
  _Hbase_createTable_presult__isset() : io(false), ia(false), exist(false) {}
  bool io;
  bool ia;
  bool exist;
} _Hbase_createTable_presult__isset;

class Hbase_createTable_presult {
 public:


  virtual ~Hbase_createTable_presult() throw() {}

  IOError io;
  IllegalArgument ia;
  AlreadyExists exist;

  _Hbase_createTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_deleteTable_args__isset {
  _Hbase_deleteTable_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_deleteTable_args__isset;

class Hbase_deleteTable_args {
 public:

  Hbase_deleteTable_args() : tableName("") {
  }

  virtual ~Hbase_deleteTable_args() throw() {}

  Text tableName;

  _Hbase_deleteTable_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  bool operator == (const Hbase_deleteTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_deleteTable_pargs {
 public:


  virtual ~Hbase_deleteTable_pargs() throw() {}

  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteTable_result__isset {
  _Hbase_deleteTable_result__isset() : io(false) {}
  bool io;
} _Hbase_deleteTable_result__isset;

class Hbase_deleteTable_result {
 public:

  Hbase_deleteTable_result() {
  }

  virtual ~Hbase_deleteTable_result() throw() {}

  IOError io;

  _Hbase_deleteTable_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_deleteTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteTable_presult__isset {
  _Hbase_deleteTable_presult__isset() : io(false) {}
  bool io;
} _Hbase_deleteTable_presult__isset;

class Hbase_deleteTable_presult {
 public:


  virtual ~Hbase_deleteTable_presult() throw() {}

  IOError io;

  _Hbase_deleteTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_get_args__isset {
  _Hbase_get_args__isset() : tableName(false), row(false), column(false) {}
  bool tableName;
  bool row;
  bool column;
} _Hbase_get_args__isset;

class Hbase_get_args {
 public:

  Hbase_get_args() : tableName(""), row(""), column("") {
  }

  virtual ~Hbase_get_args() throw() {}

  Text tableName;
  Text row;
  Text column;

  _Hbase_get_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  bool operator == (const Hbase_get_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    return true;
  }
  bool operator != (const Hbase_get_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_get_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_get_pargs {
 public:


  virtual ~Hbase_get_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_get_result__isset {
  _Hbase_get_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_get_result__isset;

class Hbase_get_result {
 public:

  Hbase_get_result() {
  }

  virtual ~Hbase_get_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  _Hbase_get_result__isset __isset;

  void __set_success(const std::vector<TCell> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_get_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_get_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_get_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_get_presult__isset {
  _Hbase_get_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_get_presult__isset;

class Hbase_get_presult {
 public:


  virtual ~Hbase_get_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  _Hbase_get_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getVer_args__isset {
  _Hbase_getVer_args__isset() : tableName(false), row(false), column(false), numVersions(false) {}
  bool tableName;
  bool row;
  bool column;
  bool numVersions;
} _Hbase_getVer_args__isset;

class Hbase_getVer_args {
 public:

  Hbase_getVer_args() : tableName(""), row(""), column(""), numVersions(0) {
  }

  virtual ~Hbase_getVer_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int32_t numVersions;

  _Hbase_getVer_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  void __set_numVersions(const int32_t val) {
    numVersions = val;
  }

  bool operator == (const Hbase_getVer_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(numVersions == rhs.numVersions))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getVer_pargs {
 public:


  virtual ~Hbase_getVer_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int32_t* numVersions;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getVer_result__isset {
  _Hbase_getVer_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getVer_result__isset;

class Hbase_getVer_result {
 public:

  Hbase_getVer_result() {
  }

  virtual ~Hbase_getVer_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  _Hbase_getVer_result__isset __isset;

  void __set_success(const std::vector<TCell> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getVer_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getVer_presult__isset {
  _Hbase_getVer_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getVer_presult__isset;

class Hbase_getVer_presult {
 public:


  virtual ~Hbase_getVer_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  _Hbase_getVer_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getVerTs_args__isset {
  _Hbase_getVerTs_args__isset() : tableName(false), row(false), column(false), timestamp(false), numVersions(false) {}
  bool tableName;
  bool row;
  bool column;
  bool timestamp;
  bool numVersions;
} _Hbase_getVerTs_args__isset;

class Hbase_getVerTs_args {
 public:

  Hbase_getVerTs_args() : tableName(""), row(""), column(""), timestamp(0), numVersions(0) {
  }

  virtual ~Hbase_getVerTs_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int64_t timestamp;
  int32_t numVersions;

  _Hbase_getVerTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_numVersions(const int32_t val) {
    numVersions = val;
  }

  bool operator == (const Hbase_getVerTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(numVersions == rhs.numVersions))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVerTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVerTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getVerTs_pargs {
 public:


  virtual ~Hbase_getVerTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* timestamp;
  const int32_t* numVersions;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getVerTs_result__isset {
  _Hbase_getVerTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getVerTs_result__isset;

class Hbase_getVerTs_result {
 public:

  Hbase_getVerTs_result() {
  }

  virtual ~Hbase_getVerTs_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  _Hbase_getVerTs_result__isset __isset;

  void __set_success(const std::vector<TCell> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getVerTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVerTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVerTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getVerTs_presult__isset {
  _Hbase_getVerTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getVerTs_presult__isset;

class Hbase_getVerTs_presult {
 public:


  virtual ~Hbase_getVerTs_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  _Hbase_getVerTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRow_args__isset {
  _Hbase_getRow_args__isset() : tableName(false), row(false) {}
  bool tableName;
  bool row;
} _Hbase_getRow_args__isset;

class Hbase_getRow_args {
 public:

  Hbase_getRow_args() : tableName(""), row("") {
  }

  virtual ~Hbase_getRow_args() throw() {}

  Text tableName;
  Text row;

  _Hbase_getRow_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  bool operator == (const Hbase_getRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRow_pargs {
 public:


  virtual ~Hbase_getRow_pargs() throw() {}

  const Text* tableName;
  const Text* row;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRow_result__isset {
  _Hbase_getRow_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRow_result__isset;

class Hbase_getRow_result {
 public:

  Hbase_getRow_result() {
  }

  virtual ~Hbase_getRow_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRow_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRow_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRow_presult__isset {
  _Hbase_getRow_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRow_presult__isset;

class Hbase_getRow_presult {
 public:


  virtual ~Hbase_getRow_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowWithColumns_args__isset {
  _Hbase_getRowWithColumns_args__isset() : tableName(false), row(false), columns(false) {}
  bool tableName;
  bool row;
  bool columns;
} _Hbase_getRowWithColumns_args__isset;

class Hbase_getRowWithColumns_args {
 public:

  Hbase_getRowWithColumns_args() : tableName(""), row("") {
  }

  virtual ~Hbase_getRowWithColumns_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Text>  columns;

  _Hbase_getRowWithColumns_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  bool operator == (const Hbase_getRowWithColumns_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(columns == rhs.columns))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumns_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumns_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowWithColumns_pargs {
 public:


  virtual ~Hbase_getRowWithColumns_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Text> * columns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumns_result__isset {
  _Hbase_getRowWithColumns_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumns_result__isset;

class Hbase_getRowWithColumns_result {
 public:

  Hbase_getRowWithColumns_result() {
  }

  virtual ~Hbase_getRowWithColumns_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowWithColumns_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowWithColumns_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumns_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumns_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumns_presult__isset {
  _Hbase_getRowWithColumns_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumns_presult__isset;

class Hbase_getRowWithColumns_presult {
 public:


  virtual ~Hbase_getRowWithColumns_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowWithColumns_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowTs_args__isset {
  _Hbase_getRowTs_args__isset() : tableName(false), row(false), timestamp(false) {}
  bool tableName;
  bool row;
  bool timestamp;
} _Hbase_getRowTs_args__isset;

class Hbase_getRowTs_args {
 public:

  Hbase_getRowTs_args() : tableName(""), row(""), timestamp(0) {
  }

  virtual ~Hbase_getRowTs_args() throw() {}

  Text tableName;
  Text row;
  int64_t timestamp;

  _Hbase_getRowTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_getRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowTs_pargs {
 public:


  virtual ~Hbase_getRowTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowTs_result__isset {
  _Hbase_getRowTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowTs_result__isset;

class Hbase_getRowTs_result {
 public:

  Hbase_getRowTs_result() {
  }

  virtual ~Hbase_getRowTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowTs_presult__isset {
  _Hbase_getRowTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowTs_presult__isset;

class Hbase_getRowTs_presult {
 public:


  virtual ~Hbase_getRowTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowWithColumnsTs_args__isset {
  _Hbase_getRowWithColumnsTs_args__isset() : tableName(false), row(false), columns(false), timestamp(false) {}
  bool tableName;
  bool row;
  bool columns;
  bool timestamp;
} _Hbase_getRowWithColumnsTs_args__isset;

class Hbase_getRowWithColumnsTs_args {
 public:

  Hbase_getRowWithColumnsTs_args() : tableName(""), row(""), timestamp(0) {
  }

  virtual ~Hbase_getRowWithColumnsTs_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Text>  columns;
  int64_t timestamp;

  _Hbase_getRowWithColumnsTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_getRowWithColumnsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowWithColumnsTs_pargs {
 public:


  virtual ~Hbase_getRowWithColumnsTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Text> * columns;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumnsTs_result__isset {
  _Hbase_getRowWithColumnsTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumnsTs_result__isset;

class Hbase_getRowWithColumnsTs_result {
 public:

  Hbase_getRowWithColumnsTs_result() {
  }

  virtual ~Hbase_getRowWithColumnsTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowWithColumnsTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowWithColumnsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumnsTs_presult__isset {
  _Hbase_getRowWithColumnsTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumnsTs_presult__isset;

class Hbase_getRowWithColumnsTs_presult {
 public:


  virtual ~Hbase_getRowWithColumnsTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowWithColumnsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowWithColumnPrefix_args__isset {
  _Hbase_getRowWithColumnPrefix_args__isset() : tableName(false), row(false), prefix(false) {}
  bool tableName;
  bool row;
  bool prefix;
} _Hbase_getRowWithColumnPrefix_args__isset;

class Hbase_getRowWithColumnPrefix_args {
 public:

  Hbase_getRowWithColumnPrefix_args() : tableName(""), row(""), prefix("") {
  }

  virtual ~Hbase_getRowWithColumnPrefix_args() throw() {}

  Text tableName;
  Text row;
  Text prefix;

  _Hbase_getRowWithColumnPrefix_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_prefix(const Text& val) {
    prefix = val;
  }

  bool operator == (const Hbase_getRowWithColumnPrefix_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(prefix == rhs.prefix))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnPrefix_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnPrefix_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowWithColumnPrefix_pargs {
 public:


  virtual ~Hbase_getRowWithColumnPrefix_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* prefix;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumnPrefix_result__isset {
  _Hbase_getRowWithColumnPrefix_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumnPrefix_result__isset;

class Hbase_getRowWithColumnPrefix_result {
 public:

  Hbase_getRowWithColumnPrefix_result() {
  }

  virtual ~Hbase_getRowWithColumnPrefix_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowWithColumnPrefix_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowWithColumnPrefix_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnPrefix_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnPrefix_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumnPrefix_presult__isset {
  _Hbase_getRowWithColumnPrefix_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumnPrefix_presult__isset;

class Hbase_getRowWithColumnPrefix_presult {
 public:


  virtual ~Hbase_getRowWithColumnPrefix_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowWithColumnPrefix_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowWithColumnPrefixTs_args__isset {
  _Hbase_getRowWithColumnPrefixTs_args__isset() : tableName(false), row(false), prefix(false), timestamp(false) {}
  bool tableName;
  bool row;
  bool prefix;
  bool timestamp;
} _Hbase_getRowWithColumnPrefixTs_args__isset;

class Hbase_getRowWithColumnPrefixTs_args {
 public:

  Hbase_getRowWithColumnPrefixTs_args() : tableName(""), row(""), prefix(""), timestamp(0) {
  }

  virtual ~Hbase_getRowWithColumnPrefixTs_args() throw() {}

  Text tableName;
  Text row;
  Text prefix;
  int64_t timestamp;

  _Hbase_getRowWithColumnPrefixTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_prefix(const Text& val) {
    prefix = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_getRowWithColumnPrefixTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(prefix == rhs.prefix))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnPrefixTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnPrefixTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowWithColumnPrefixTs_pargs {
 public:


  virtual ~Hbase_getRowWithColumnPrefixTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* prefix;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumnPrefixTs_result__isset {
  _Hbase_getRowWithColumnPrefixTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumnPrefixTs_result__isset;

class Hbase_getRowWithColumnPrefixTs_result {
 public:

  Hbase_getRowWithColumnPrefixTs_result() {
  }

  virtual ~Hbase_getRowWithColumnPrefixTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowWithColumnPrefixTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowWithColumnPrefixTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnPrefixTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnPrefixTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumnPrefixTs_presult__isset {
  _Hbase_getRowWithColumnPrefixTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumnPrefixTs_presult__isset;

class Hbase_getRowWithColumnPrefixTs_presult {
 public:


  virtual ~Hbase_getRowWithColumnPrefixTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowWithColumnPrefixTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowWithMultipleColumnPrefixes_args__isset {
  _Hbase_getRowWithMultipleColumnPrefixes_args__isset() : tableName(false), row(false), families(false), columnPrefixes(false) {}
  bool tableName;
  bool row;
  bool families;
  bool columnPrefixes;
} _Hbase_getRowWithMultipleColumnPrefixes_args__isset;

class Hbase_getRowWithMultipleColumnPrefixes_args {
 public:

  Hbase_getRowWithMultipleColumnPrefixes_args() : tableName(""), row("") {
  }

  virtual ~Hbase_getRowWithMultipleColumnPrefixes_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Text>  families;
  std::vector<Text>  columnPrefixes;

  _Hbase_getRowWithMultipleColumnPrefixes_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_families(const std::vector<Text> & val) {
    families = val;
  }

  void __set_columnPrefixes(const std::vector<Text> & val) {
    columnPrefixes = val;
  }

  bool operator == (const Hbase_getRowWithMultipleColumnPrefixes_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(families == rhs.families))
      return false;
    if (!(columnPrefixes == rhs.columnPrefixes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithMultipleColumnPrefixes_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithMultipleColumnPrefixes_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowWithMultipleColumnPrefixes_pargs {
 public:


  virtual ~Hbase_getRowWithMultipleColumnPrefixes_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Text> * families;
  const std::vector<Text> * columnPrefixes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithMultipleColumnPrefixes_result__isset {
  _Hbase_getRowWithMultipleColumnPrefixes_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithMultipleColumnPrefixes_result__isset;

class Hbase_getRowWithMultipleColumnPrefixes_result {
 public:

  Hbase_getRowWithMultipleColumnPrefixes_result() {
  }

  virtual ~Hbase_getRowWithMultipleColumnPrefixes_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowWithMultipleColumnPrefixes_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowWithMultipleColumnPrefixes_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithMultipleColumnPrefixes_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithMultipleColumnPrefixes_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithMultipleColumnPrefixes_presult__isset {
  _Hbase_getRowWithMultipleColumnPrefixes_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithMultipleColumnPrefixes_presult__isset;

class Hbase_getRowWithMultipleColumnPrefixes_presult {
 public:


  virtual ~Hbase_getRowWithMultipleColumnPrefixes_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowWithMultipleColumnPrefixes_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowWithMultipleColumnPrefixesTs_args__isset {
  _Hbase_getRowWithMultipleColumnPrefixesTs_args__isset() : tableName(false), row(false), families(false), columnPrefixes(false), timestamp(false) {}
  bool tableName;
  bool row;
  bool families;
  bool columnPrefixes;
  bool timestamp;
} _Hbase_getRowWithMultipleColumnPrefixesTs_args__isset;

class Hbase_getRowWithMultipleColumnPrefixesTs_args {
 public:

  Hbase_getRowWithMultipleColumnPrefixesTs_args() : tableName(""), row(""), timestamp(0) {
  }

  virtual ~Hbase_getRowWithMultipleColumnPrefixesTs_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Text>  families;
  std::vector<Text>  columnPrefixes;
  int64_t timestamp;

  _Hbase_getRowWithMultipleColumnPrefixesTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_families(const std::vector<Text> & val) {
    families = val;
  }

  void __set_columnPrefixes(const std::vector<Text> & val) {
    columnPrefixes = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_getRowWithMultipleColumnPrefixesTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(families == rhs.families))
      return false;
    if (!(columnPrefixes == rhs.columnPrefixes))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithMultipleColumnPrefixesTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithMultipleColumnPrefixesTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowWithMultipleColumnPrefixesTs_pargs {
 public:


  virtual ~Hbase_getRowWithMultipleColumnPrefixesTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Text> * families;
  const std::vector<Text> * columnPrefixes;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithMultipleColumnPrefixesTs_result__isset {
  _Hbase_getRowWithMultipleColumnPrefixesTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithMultipleColumnPrefixesTs_result__isset;

class Hbase_getRowWithMultipleColumnPrefixesTs_result {
 public:

  Hbase_getRowWithMultipleColumnPrefixesTs_result() {
  }

  virtual ~Hbase_getRowWithMultipleColumnPrefixesTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowWithMultipleColumnPrefixesTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowWithMultipleColumnPrefixesTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithMultipleColumnPrefixesTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithMultipleColumnPrefixesTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithMultipleColumnPrefixesTs_presult__isset {
  _Hbase_getRowWithMultipleColumnPrefixesTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithMultipleColumnPrefixesTs_presult__isset;

class Hbase_getRowWithMultipleColumnPrefixesTs_presult {
 public:


  virtual ~Hbase_getRowWithMultipleColumnPrefixesTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowWithMultipleColumnPrefixesTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRows_args__isset {
  _Hbase_getRows_args__isset() : tableName(false), rows(false) {}
  bool tableName;
  bool rows;
} _Hbase_getRows_args__isset;

class Hbase_getRows_args {
 public:

  Hbase_getRows_args() : tableName("") {
  }

  virtual ~Hbase_getRows_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;

  _Hbase_getRows_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rows(const std::vector<Text> & val) {
    rows = val;
  }

  bool operator == (const Hbase_getRows_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRows_pargs {
 public:


  virtual ~Hbase_getRows_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRows_result__isset {
  _Hbase_getRows_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRows_result__isset;

class Hbase_getRows_result {
 public:

  Hbase_getRows_result() {
  }

  virtual ~Hbase_getRows_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRows_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRows_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRows_presult__isset {
  _Hbase_getRows_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRows_presult__isset;

class Hbase_getRows_presult {
 public:


  virtual ~Hbase_getRows_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRows_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowsTs_args__isset {
  _Hbase_getRowsTs_args__isset() : tableName(false), rows(false), timestamp(false) {}
  bool tableName;
  bool rows;
  bool timestamp;
} _Hbase_getRowsTs_args__isset;

class Hbase_getRowsTs_args {
 public:

  Hbase_getRowsTs_args() : tableName(""), timestamp(0) {
  }

  virtual ~Hbase_getRowsTs_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;
  int64_t timestamp;

  _Hbase_getRowsTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rows(const std::vector<Text> & val) {
    rows = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_getRowsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowsTs_pargs {
 public:


  virtual ~Hbase_getRowsTs_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsTs_result__isset {
  _Hbase_getRowsTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsTs_result__isset;

class Hbase_getRowsTs_result {
 public:

  Hbase_getRowsTs_result() {
  }

  virtual ~Hbase_getRowsTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowsTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsTs_presult__isset {
  _Hbase_getRowsTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsTs_presult__isset;

class Hbase_getRowsTs_presult {
 public:


  virtual ~Hbase_getRowsTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowsWithColumns_args__isset {
  _Hbase_getRowsWithColumns_args__isset() : tableName(false), rows(false), families(false) {}
  bool tableName;
  bool rows;
  bool families;
} _Hbase_getRowsWithColumns_args__isset;

class Hbase_getRowsWithColumns_args {
 public:

  Hbase_getRowsWithColumns_args() : tableName("") {
  }

  virtual ~Hbase_getRowsWithColumns_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;
  std::vector<Text>  families;

  _Hbase_getRowsWithColumns_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rows(const std::vector<Text> & val) {
    rows = val;
  }

  void __set_families(const std::vector<Text> & val) {
    families = val;
  }

  bool operator == (const Hbase_getRowsWithColumns_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(families == rhs.families))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumns_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumns_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowsWithColumns_pargs {
 public:


  virtual ~Hbase_getRowsWithColumns_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;
  const std::vector<Text> * families;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsWithColumns_result__isset {
  _Hbase_getRowsWithColumns_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsWithColumns_result__isset;

class Hbase_getRowsWithColumns_result {
 public:

  Hbase_getRowsWithColumns_result() {
  }

  virtual ~Hbase_getRowsWithColumns_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowsWithColumns_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowsWithColumns_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumns_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumns_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsWithColumns_presult__isset {
  _Hbase_getRowsWithColumns_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsWithColumns_presult__isset;

class Hbase_getRowsWithColumns_presult {
 public:


  virtual ~Hbase_getRowsWithColumns_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowsWithColumns_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowsWithColumnsTs_args__isset {
  _Hbase_getRowsWithColumnsTs_args__isset() : tableName(false), rows(false), families(false), timestamp(false) {}
  bool tableName;
  bool rows;
  bool families;
  bool timestamp;
} _Hbase_getRowsWithColumnsTs_args__isset;

class Hbase_getRowsWithColumnsTs_args {
 public:

  Hbase_getRowsWithColumnsTs_args() : tableName(""), timestamp(0) {
  }

  virtual ~Hbase_getRowsWithColumnsTs_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;
  std::vector<Text>  families;
  int64_t timestamp;

  _Hbase_getRowsWithColumnsTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rows(const std::vector<Text> & val) {
    rows = val;
  }

  void __set_families(const std::vector<Text> & val) {
    families = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_getRowsWithColumnsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(families == rhs.families))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumnsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumnsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowsWithColumnsTs_pargs {
 public:


  virtual ~Hbase_getRowsWithColumnsTs_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;
  const std::vector<Text> * families;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsWithColumnsTs_result__isset {
  _Hbase_getRowsWithColumnsTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsWithColumnsTs_result__isset;

class Hbase_getRowsWithColumnsTs_result {
 public:

  Hbase_getRowsWithColumnsTs_result() {
  }

  virtual ~Hbase_getRowsWithColumnsTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowsWithColumnsTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowsWithColumnsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumnsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumnsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsWithColumnsTs_presult__isset {
  _Hbase_getRowsWithColumnsTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsWithColumnsTs_presult__isset;

class Hbase_getRowsWithColumnsTs_presult {
 public:


  virtual ~Hbase_getRowsWithColumnsTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowsWithColumnsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_mutateRow_args__isset {
  _Hbase_mutateRow_args__isset() : tableName(false), row(false), mutations(false), attributes(false) {}
  bool tableName;
  bool row;
  bool mutations;
  bool attributes;
} _Hbase_mutateRow_args__isset;

class Hbase_mutateRow_args {
 public:

  Hbase_mutateRow_args() : tableName(""), row("") {
  }

  virtual ~Hbase_mutateRow_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Mutation>  mutations;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRow_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_mutations(const std::vector<Mutation> & val) {
    mutations = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_mutateRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_mutateRow_pargs {
 public:


  virtual ~Hbase_mutateRow_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Mutation> * mutations;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRow_result__isset {
  _Hbase_mutateRow_result__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRow_result__isset;

class Hbase_mutateRow_result {
 public:

  Hbase_mutateRow_result() {
  }

  virtual ~Hbase_mutateRow_result() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRow_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_mutateRow_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRow_presult__isset {
  _Hbase_mutateRow_presult__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRow_presult__isset;

class Hbase_mutateRow_presult {
 public:


  virtual ~Hbase_mutateRow_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_mutateRowTs_args__isset {
  _Hbase_mutateRowTs_args__isset() : tableName(false), row(false), mutations(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool row;
  bool mutations;
  bool timestamp;
  bool attributes;
} _Hbase_mutateRowTs_args__isset;

class Hbase_mutateRowTs_args {
 public:

  Hbase_mutateRowTs_args() : tableName(""), row(""), timestamp(0) {
  }

  virtual ~Hbase_mutateRowTs_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Mutation>  mutations;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRowTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_mutations(const std::vector<Mutation> & val) {
    mutations = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_mutateRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_mutateRowTs_pargs {
 public:


  virtual ~Hbase_mutateRowTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Mutation> * mutations;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRowTs_result__isset {
  _Hbase_mutateRowTs_result__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRowTs_result__isset;

class Hbase_mutateRowTs_result {
 public:

  Hbase_mutateRowTs_result() {
  }

  virtual ~Hbase_mutateRowTs_result() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowTs_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_mutateRowTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRowTs_presult__isset {
  _Hbase_mutateRowTs_presult__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRowTs_presult__isset;

class Hbase_mutateRowTs_presult {
 public:


  virtual ~Hbase_mutateRowTs_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_mutateRows_args__isset {
  _Hbase_mutateRows_args__isset() : tableName(false), rowBatches(false), attributes(false) {}
  bool tableName;
  bool rowBatches;
  bool attributes;
} _Hbase_mutateRows_args__isset;

class Hbase_mutateRows_args {
 public:

  Hbase_mutateRows_args() : tableName("") {
  }

  virtual ~Hbase_mutateRows_args() throw() {}

  Text tableName;
  std::vector<BatchMutation>  rowBatches;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRows_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rowBatches(const std::vector<BatchMutation> & val) {
    rowBatches = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_mutateRows_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rowBatches == rhs.rowBatches))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_mutateRows_pargs {
 public:


  virtual ~Hbase_mutateRows_pargs() throw() {}

  const Text* tableName;
  const std::vector<BatchMutation> * rowBatches;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRows_result__isset {
  _Hbase_mutateRows_result__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRows_result__isset;

class Hbase_mutateRows_result {
 public:

  Hbase_mutateRows_result() {
  }

  virtual ~Hbase_mutateRows_result() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRows_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_mutateRows_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRows_presult__isset {
  _Hbase_mutateRows_presult__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRows_presult__isset;

class Hbase_mutateRows_presult {
 public:


  virtual ~Hbase_mutateRows_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRows_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_mutateRowsTs_args__isset {
  _Hbase_mutateRowsTs_args__isset() : tableName(false), rowBatches(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool rowBatches;
  bool timestamp;
  bool attributes;
} _Hbase_mutateRowsTs_args__isset;

class Hbase_mutateRowsTs_args {
 public:

  Hbase_mutateRowsTs_args() : tableName(""), timestamp(0) {
  }

  virtual ~Hbase_mutateRowsTs_args() throw() {}

  Text tableName;
  std::vector<BatchMutation>  rowBatches;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRowsTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rowBatches(const std::vector<BatchMutation> & val) {
    rowBatches = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_mutateRowsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rowBatches == rhs.rowBatches))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_mutateRowsTs_pargs {
 public:


  virtual ~Hbase_mutateRowsTs_pargs() throw() {}

  const Text* tableName;
  const std::vector<BatchMutation> * rowBatches;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRowsTs_result__isset {
  _Hbase_mutateRowsTs_result__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRowsTs_result__isset;

class Hbase_mutateRowsTs_result {
 public:

  Hbase_mutateRowsTs_result() {
  }

  virtual ~Hbase_mutateRowsTs_result() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowsTs_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_mutateRowsTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRowsTs_presult__isset {
  _Hbase_mutateRowsTs_presult__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRowsTs_presult__isset;

class Hbase_mutateRowsTs_presult {
 public:


  virtual ~Hbase_mutateRowsTs_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_checkAndMutateRow_args__isset {
  _Hbase_checkAndMutateRow_args__isset() : tableName(false), row(false), columnCheck(false), valueCheck(false), mutations(false), attributes(false) {}
  bool tableName;
  bool row;
  bool columnCheck;
  bool valueCheck;
  bool mutations;
  bool attributes;
} _Hbase_checkAndMutateRow_args__isset;

class Hbase_checkAndMutateRow_args {
 public:

  Hbase_checkAndMutateRow_args() : tableName(""), row(""), columnCheck(""), valueCheck("") {
  }

  virtual ~Hbase_checkAndMutateRow_args() throw() {}

  Text tableName;
  Text row;
  Text columnCheck;
  Text valueCheck;
  std::vector<Mutation>  mutations;
  std::map<Text, Text>  attributes;

  _Hbase_checkAndMutateRow_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_columnCheck(const Text& val) {
    columnCheck = val;
  }

  void __set_valueCheck(const Text& val) {
    valueCheck = val;
  }

  void __set_mutations(const std::vector<Mutation> & val) {
    mutations = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_checkAndMutateRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(columnCheck == rhs.columnCheck))
      return false;
    if (!(valueCheck == rhs.valueCheck))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_checkAndMutateRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_checkAndMutateRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_checkAndMutateRow_pargs {
 public:


  virtual ~Hbase_checkAndMutateRow_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* columnCheck;
  const Text* valueCheck;
  const std::vector<Mutation> * mutations;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_checkAndMutateRow_result__isset {
  _Hbase_checkAndMutateRow_result__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_checkAndMutateRow_result__isset;

class Hbase_checkAndMutateRow_result {
 public:

  Hbase_checkAndMutateRow_result() : success(0) {
  }

  virtual ~Hbase_checkAndMutateRow_result() throw() {}

  bool success;
  IOError io;
  IllegalArgument ia;

  _Hbase_checkAndMutateRow_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_checkAndMutateRow_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_checkAndMutateRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_checkAndMutateRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_checkAndMutateRow_presult__isset {
  _Hbase_checkAndMutateRow_presult__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_checkAndMutateRow_presult__isset;

class Hbase_checkAndMutateRow_presult {
 public:


  virtual ~Hbase_checkAndMutateRow_presult() throw() {}

  bool* success;
  IOError io;
  IllegalArgument ia;

  _Hbase_checkAndMutateRow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_checkAndMutateRowTs_args__isset {
  _Hbase_checkAndMutateRowTs_args__isset() : tableName(false), row(false), columnCheck(false), valueCheck(false), mutations(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool row;
  bool columnCheck;
  bool valueCheck;
  bool mutations;
  bool timestamp;
  bool attributes;
} _Hbase_checkAndMutateRowTs_args__isset;

class Hbase_checkAndMutateRowTs_args {
 public:

  Hbase_checkAndMutateRowTs_args() : tableName(""), row(""), columnCheck(""), valueCheck(""), timestamp(0) {
  }

  virtual ~Hbase_checkAndMutateRowTs_args() throw() {}

  Text tableName;
  Text row;
  Text columnCheck;
  Text valueCheck;
  std::vector<Mutation>  mutations;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_checkAndMutateRowTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_columnCheck(const Text& val) {
    columnCheck = val;
  }

  void __set_valueCheck(const Text& val) {
    valueCheck = val;
  }

  void __set_mutations(const std::vector<Mutation> & val) {
    mutations = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_checkAndMutateRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(columnCheck == rhs.columnCheck))
      return false;
    if (!(valueCheck == rhs.valueCheck))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_checkAndMutateRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_checkAndMutateRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_checkAndMutateRowTs_pargs {
 public:


  virtual ~Hbase_checkAndMutateRowTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* columnCheck;
  const Text* valueCheck;
  const std::vector<Mutation> * mutations;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_checkAndMutateRowTs_result__isset {
  _Hbase_checkAndMutateRowTs_result__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_checkAndMutateRowTs_result__isset;

class Hbase_checkAndMutateRowTs_result {
 public:

  Hbase_checkAndMutateRowTs_result() : success(0) {
  }

  virtual ~Hbase_checkAndMutateRowTs_result() throw() {}

  bool success;
  IOError io;
  IllegalArgument ia;

  _Hbase_checkAndMutateRowTs_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_checkAndMutateRowTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_checkAndMutateRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_checkAndMutateRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_checkAndMutateRowTs_presult__isset {
  _Hbase_checkAndMutateRowTs_presult__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_checkAndMutateRowTs_presult__isset;

class Hbase_checkAndMutateRowTs_presult {
 public:


  virtual ~Hbase_checkAndMutateRowTs_presult() throw() {}

  bool* success;
  IOError io;
  IllegalArgument ia;

  _Hbase_checkAndMutateRowTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_atomicIncrement_args__isset {
  _Hbase_atomicIncrement_args__isset() : tableName(false), row(false), column(false), value(false) {}
  bool tableName;
  bool row;
  bool column;
  bool value;
} _Hbase_atomicIncrement_args__isset;

class Hbase_atomicIncrement_args {
 public:

  Hbase_atomicIncrement_args() : tableName(""), row(""), column(""), value(0) {
  }

  virtual ~Hbase_atomicIncrement_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int64_t value;

  _Hbase_atomicIncrement_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  void __set_value(const int64_t val) {
    value = val;
  }

  bool operator == (const Hbase_atomicIncrement_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Hbase_atomicIncrement_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_atomicIncrement_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_atomicIncrement_pargs {
 public:


  virtual ~Hbase_atomicIncrement_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_atomicIncrement_result__isset {
  _Hbase_atomicIncrement_result__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_atomicIncrement_result__isset;

class Hbase_atomicIncrement_result {
 public:

  Hbase_atomicIncrement_result() : success(0) {
  }

  virtual ~Hbase_atomicIncrement_result() throw() {}

  int64_t success;
  IOError io;
  IllegalArgument ia;

  _Hbase_atomicIncrement_result__isset __isset;

  void __set_success(const int64_t val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_atomicIncrement_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_atomicIncrement_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_atomicIncrement_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_atomicIncrement_presult__isset {
  _Hbase_atomicIncrement_presult__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_atomicIncrement_presult__isset;

class Hbase_atomicIncrement_presult {
 public:


  virtual ~Hbase_atomicIncrement_presult() throw() {}

  int64_t* success;
  IOError io;
  IllegalArgument ia;

  _Hbase_atomicIncrement_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_deleteAll_args__isset {
  _Hbase_deleteAll_args__isset() : tableName(false), row(false), column(false) {}
  bool tableName;
  bool row;
  bool column;
} _Hbase_deleteAll_args__isset;

class Hbase_deleteAll_args {
 public:

  Hbase_deleteAll_args() : tableName(""), row(""), column("") {
  }

  virtual ~Hbase_deleteAll_args() throw() {}

  Text tableName;
  Text row;
  Text column;

  _Hbase_deleteAll_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  bool operator == (const Hbase_deleteAll_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAll_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAll_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_deleteAll_pargs {
 public:


  virtual ~Hbase_deleteAll_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAll_result__isset {
  _Hbase_deleteAll_result__isset() : io(false) {}
  bool io;
} _Hbase_deleteAll_result__isset;

class Hbase_deleteAll_result {
 public:

  Hbase_deleteAll_result() {
  }

  virtual ~Hbase_deleteAll_result() throw() {}

  IOError io;

  _Hbase_deleteAll_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_deleteAll_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAll_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAll_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAll_presult__isset {
  _Hbase_deleteAll_presult__isset() : io(false) {}
  bool io;
} _Hbase_deleteAll_presult__isset;

class Hbase_deleteAll_presult {
 public:


  virtual ~Hbase_deleteAll_presult() throw() {}

  IOError io;

  _Hbase_deleteAll_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_deleteAllTs_args__isset {
  _Hbase_deleteAllTs_args__isset() : tableName(false), row(false), column(false), timestamp(false) {}
  bool tableName;
  bool row;
  bool column;
  bool timestamp;
} _Hbase_deleteAllTs_args__isset;

class Hbase_deleteAllTs_args {
 public:

  Hbase_deleteAllTs_args() : tableName(""), row(""), column(""), timestamp(0) {
  }

  virtual ~Hbase_deleteAllTs_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int64_t timestamp;

  _Hbase_deleteAllTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_deleteAllTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_deleteAllTs_pargs {
 public:


  virtual ~Hbase_deleteAllTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllTs_result__isset {
  _Hbase_deleteAllTs_result__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllTs_result__isset;

class Hbase_deleteAllTs_result {
 public:

  Hbase_deleteAllTs_result() {
  }

  virtual ~Hbase_deleteAllTs_result() throw() {}

  IOError io;

  _Hbase_deleteAllTs_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_deleteAllTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllTs_presult__isset {
  _Hbase_deleteAllTs_presult__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllTs_presult__isset;

class Hbase_deleteAllTs_presult {
 public:


  virtual ~Hbase_deleteAllTs_presult() throw() {}

  IOError io;

  _Hbase_deleteAllTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_deleteAllRow_args__isset {
  _Hbase_deleteAllRow_args__isset() : tableName(false), row(false), attributes(false) {}
  bool tableName;
  bool row;
  bool attributes;
} _Hbase_deleteAllRow_args__isset;

class Hbase_deleteAllRow_args {
 public:

  Hbase_deleteAllRow_args() : tableName(""), row("") {
  }

  virtual ~Hbase_deleteAllRow_args() throw() {}

  Text tableName;
  Text row;
  std::map<Text, Text>  attributes;

  _Hbase_deleteAllRow_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_deleteAllRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_deleteAllRow_pargs {
 public:


  virtual ~Hbase_deleteAllRow_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllRow_result__isset {
  _Hbase_deleteAllRow_result__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllRow_result__isset;

class Hbase_deleteAllRow_result {
 public:

  Hbase_deleteAllRow_result() {
  }

  virtual ~Hbase_deleteAllRow_result() throw() {}

  IOError io;

  _Hbase_deleteAllRow_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_deleteAllRow_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllRow_presult__isset {
  _Hbase_deleteAllRow_presult__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllRow_presult__isset;

class Hbase_deleteAllRow_presult {
 public:


  virtual ~Hbase_deleteAllRow_presult() throw() {}

  IOError io;

  _Hbase_deleteAllRow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_deleteAllRowTs_args__isset {
  _Hbase_deleteAllRowTs_args__isset() : tableName(false), row(false), timestamp(false) {}
  bool tableName;
  bool row;
  bool timestamp;
} _Hbase_deleteAllRowTs_args__isset;

class Hbase_deleteAllRowTs_args {
 public:

  Hbase_deleteAllRowTs_args() : tableName(""), row(""), timestamp(0) {
  }

  virtual ~Hbase_deleteAllRowTs_args() throw() {}

  Text tableName;
  Text row;
  int64_t timestamp;

  _Hbase_deleteAllRowTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_deleteAllRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_deleteAllRowTs_pargs {
 public:


  virtual ~Hbase_deleteAllRowTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllRowTs_result__isset {
  _Hbase_deleteAllRowTs_result__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllRowTs_result__isset;

class Hbase_deleteAllRowTs_result {
 public:

  Hbase_deleteAllRowTs_result() {
  }

  virtual ~Hbase_deleteAllRowTs_result() throw() {}

  IOError io;

  _Hbase_deleteAllRowTs_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_deleteAllRowTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllRowTs_presult__isset {
  _Hbase_deleteAllRowTs_presult__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllRowTs_presult__isset;

class Hbase_deleteAllRowTs_presult {
 public:


  virtual ~Hbase_deleteAllRowTs_presult() throw() {}

  IOError io;

  _Hbase_deleteAllRowTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_mutateRowsAsync_args__isset {
  _Hbase_mutateRowsAsync_args__isset() : tableName(false), rowBatches(false) {}
  bool tableName;
  bool rowBatches;
} _Hbase_mutateRowsAsync_args__isset;

class Hbase_mutateRowsAsync_args {
 public:

  Hbase_mutateRowsAsync_args() : tableName("") {
  }

  virtual ~Hbase_mutateRowsAsync_args() throw() {}

  Text tableName;
  std::vector<BatchMutation>  rowBatches;

  _Hbase_mutateRowsAsync_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rowBatches(const std::vector<BatchMutation> & val) {
    rowBatches = val;
  }

  bool operator == (const Hbase_mutateRowsAsync_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rowBatches == rhs.rowBatches))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowsAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowsAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_mutateRowsAsync_pargs {
 public:


  virtual ~Hbase_mutateRowsAsync_pargs() throw() {}

  const Text* tableName;
  const std::vector<BatchMutation> * rowBatches;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRowsTsAsync_args__isset {
  _Hbase_mutateRowsTsAsync_args__isset() : tableName(false), rowBatches(false), timestamp(false) {}
  bool tableName;
  bool rowBatches;
  bool timestamp;
} _Hbase_mutateRowsTsAsync_args__isset;

class Hbase_mutateRowsTsAsync_args {
 public:

  Hbase_mutateRowsTsAsync_args() : tableName(""), timestamp(0) {
  }

  virtual ~Hbase_mutateRowsTsAsync_args() throw() {}

  Text tableName;
  std::vector<BatchMutation>  rowBatches;
  int64_t timestamp;

  _Hbase_mutateRowsTsAsync_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rowBatches(const std::vector<BatchMutation> & val) {
    rowBatches = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_mutateRowsTsAsync_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rowBatches == rhs.rowBatches))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowsTsAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowsTsAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_mutateRowsTsAsync_pargs {
 public:


  virtual ~Hbase_mutateRowsTsAsync_pargs() throw() {}

  const Text* tableName;
  const std::vector<BatchMutation> * rowBatches;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_taoAssocPut_args__isset {
  _Hbase_taoAssocPut_args__isset() : tableName(false), assocType(false), id1(false), id2(false), id1Type(false), id2Type(false), timestamp(false), visibility(false), update_count(false), dataVersion(false), data(false), wormhole_comment(false) {}
  bool tableName;
  bool assocType;
  bool id1;
  bool id2;
  bool id1Type;
  bool id2Type;
  bool timestamp;
  bool visibility;
  bool update_count;
  bool dataVersion;
  bool data;
  bool wormhole_comment;
} _Hbase_taoAssocPut_args__isset;

class Hbase_taoAssocPut_args {
 public:

  Hbase_taoAssocPut_args() : tableName(""), assocType(0), id1(0), id2(0), id1Type(0), id2Type(0), timestamp(0), visibility((AssocVisibility::type)0), update_count(0), dataVersion(0), data(""), wormhole_comment("") {
  }

  virtual ~Hbase_taoAssocPut_args() throw() {}

  Text tableName;
  int64_t assocType;
  int64_t id1;
  int64_t id2;
  int64_t id1Type;
  int64_t id2Type;
  int64_t timestamp;
  AssocVisibility::type visibility;
  bool update_count;
  int64_t dataVersion;
  Text data;
  Text wormhole_comment;

  _Hbase_taoAssocPut_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_assocType(const int64_t val) {
    assocType = val;
  }

  void __set_id1(const int64_t val) {
    id1 = val;
  }

  void __set_id2(const int64_t val) {
    id2 = val;
  }

  void __set_id1Type(const int64_t val) {
    id1Type = val;
  }

  void __set_id2Type(const int64_t val) {
    id2Type = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_visibility(const AssocVisibility::type val) {
    visibility = val;
  }

  void __set_update_count(const bool val) {
    update_count = val;
  }

  void __set_dataVersion(const int64_t val) {
    dataVersion = val;
  }

  void __set_data(const Text& val) {
    data = val;
  }

  void __set_wormhole_comment(const Text& val) {
    wormhole_comment = val;
  }

  bool operator == (const Hbase_taoAssocPut_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(assocType == rhs.assocType))
      return false;
    if (!(id1 == rhs.id1))
      return false;
    if (!(id2 == rhs.id2))
      return false;
    if (!(id1Type == rhs.id1Type))
      return false;
    if (!(id2Type == rhs.id2Type))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(visibility == rhs.visibility))
      return false;
    if (!(update_count == rhs.update_count))
      return false;
    if (!(dataVersion == rhs.dataVersion))
      return false;
    if (!(data == rhs.data))
      return false;
    if (!(wormhole_comment == rhs.wormhole_comment))
      return false;
    return true;
  }
  bool operator != (const Hbase_taoAssocPut_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_taoAssocPut_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_taoAssocPut_pargs {
 public:


  virtual ~Hbase_taoAssocPut_pargs() throw() {}

  const Text* tableName;
  const int64_t* assocType;
  const int64_t* id1;
  const int64_t* id2;
  const int64_t* id1Type;
  const int64_t* id2Type;
  const int64_t* timestamp;
  const AssocVisibility::type* visibility;
  const bool* update_count;
  const int64_t* dataVersion;
  const Text* data;
  const Text* wormhole_comment;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_taoAssocPut_result__isset {
  _Hbase_taoAssocPut_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_taoAssocPut_result__isset;

class Hbase_taoAssocPut_result {
 public:

  Hbase_taoAssocPut_result() : success(0) {
  }

  virtual ~Hbase_taoAssocPut_result() throw() {}

  int64_t success;
  IOError io;

  _Hbase_taoAssocPut_result__isset __isset;

  void __set_success(const int64_t val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_taoAssocPut_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_taoAssocPut_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_taoAssocPut_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_taoAssocPut_presult__isset {
  _Hbase_taoAssocPut_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_taoAssocPut_presult__isset;

class Hbase_taoAssocPut_presult {
 public:


  virtual ~Hbase_taoAssocPut_presult() throw() {}

  int64_t* success;
  IOError io;

  _Hbase_taoAssocPut_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_taoAssocDelete_args__isset {
  _Hbase_taoAssocDelete_args__isset() : tableName(false), assocType(false), id1(false), id2(false), visibility(false), update_count(false), wormhole_comment(false) {}
  bool tableName;
  bool assocType;
  bool id1;
  bool id2;
  bool visibility;
  bool update_count;
  bool wormhole_comment;
} _Hbase_taoAssocDelete_args__isset;

class Hbase_taoAssocDelete_args {
 public:

  Hbase_taoAssocDelete_args() : tableName(""), assocType(0), id1(0), id2(0), visibility((AssocVisibility::type)0), update_count(0), wormhole_comment("") {
  }

  virtual ~Hbase_taoAssocDelete_args() throw() {}

  Text tableName;
  int64_t assocType;
  int64_t id1;
  int64_t id2;
  AssocVisibility::type visibility;
  bool update_count;
  Text wormhole_comment;

  _Hbase_taoAssocDelete_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_assocType(const int64_t val) {
    assocType = val;
  }

  void __set_id1(const int64_t val) {
    id1 = val;
  }

  void __set_id2(const int64_t val) {
    id2 = val;
  }

  void __set_visibility(const AssocVisibility::type val) {
    visibility = val;
  }

  void __set_update_count(const bool val) {
    update_count = val;
  }

  void __set_wormhole_comment(const Text& val) {
    wormhole_comment = val;
  }

  bool operator == (const Hbase_taoAssocDelete_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(assocType == rhs.assocType))
      return false;
    if (!(id1 == rhs.id1))
      return false;
    if (!(id2 == rhs.id2))
      return false;
    if (!(visibility == rhs.visibility))
      return false;
    if (!(update_count == rhs.update_count))
      return false;
    if (!(wormhole_comment == rhs.wormhole_comment))
      return false;
    return true;
  }
  bool operator != (const Hbase_taoAssocDelete_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_taoAssocDelete_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_taoAssocDelete_pargs {
 public:


  virtual ~Hbase_taoAssocDelete_pargs() throw() {}

  const Text* tableName;
  const int64_t* assocType;
  const int64_t* id1;
  const int64_t* id2;
  const AssocVisibility::type* visibility;
  const bool* update_count;
  const Text* wormhole_comment;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_taoAssocDelete_result__isset {
  _Hbase_taoAssocDelete_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_taoAssocDelete_result__isset;

class Hbase_taoAssocDelete_result {
 public:

  Hbase_taoAssocDelete_result() : success(0) {
  }

  virtual ~Hbase_taoAssocDelete_result() throw() {}

  int64_t success;
  IOError io;

  _Hbase_taoAssocDelete_result__isset __isset;

  void __set_success(const int64_t val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_taoAssocDelete_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_taoAssocDelete_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_taoAssocDelete_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_taoAssocDelete_presult__isset {
  _Hbase_taoAssocDelete_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_taoAssocDelete_presult__isset;

class Hbase_taoAssocDelete_presult {
 public:


  virtual ~Hbase_taoAssocDelete_presult() throw() {}

  int64_t* success;
  IOError io;

  _Hbase_taoAssocDelete_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_taoAssocRangeGet_args__isset {
  _Hbase_taoAssocRangeGet_args__isset() : tableName(false), assocType(false), id1(false), start_time(false), end_time(false), offset(false), limit(false) {}
  bool tableName;
  bool assocType;
  bool id1;
  bool start_time;
  bool end_time;
  bool offset;
  bool limit;
} _Hbase_taoAssocRangeGet_args__isset;

class Hbase_taoAssocRangeGet_args {
 public:

  Hbase_taoAssocRangeGet_args() : tableName(""), assocType(0), id1(0), start_time(0), end_time(0), offset(0), limit(0) {
  }

  virtual ~Hbase_taoAssocRangeGet_args() throw() {}

  Text tableName;
  int64_t assocType;
  int64_t id1;
  int64_t start_time;
  int64_t end_time;
  int64_t offset;
  int64_t limit;

  _Hbase_taoAssocRangeGet_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_assocType(const int64_t val) {
    assocType = val;
  }

  void __set_id1(const int64_t val) {
    id1 = val;
  }

  void __set_start_time(const int64_t val) {
    start_time = val;
  }

  void __set_end_time(const int64_t val) {
    end_time = val;
  }

  void __set_offset(const int64_t val) {
    offset = val;
  }

  void __set_limit(const int64_t val) {
    limit = val;
  }

  bool operator == (const Hbase_taoAssocRangeGet_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(assocType == rhs.assocType))
      return false;
    if (!(id1 == rhs.id1))
      return false;
    if (!(start_time == rhs.start_time))
      return false;
    if (!(end_time == rhs.end_time))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(limit == rhs.limit))
      return false;
    return true;
  }
  bool operator != (const Hbase_taoAssocRangeGet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_taoAssocRangeGet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_taoAssocRangeGet_pargs {
 public:


  virtual ~Hbase_taoAssocRangeGet_pargs() throw() {}

  const Text* tableName;
  const int64_t* assocType;
  const int64_t* id1;
  const int64_t* start_time;
  const int64_t* end_time;
  const int64_t* offset;
  const int64_t* limit;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_taoAssocRangeGet_result__isset {
  _Hbase_taoAssocRangeGet_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_taoAssocRangeGet_result__isset;

class Hbase_taoAssocRangeGet_result {
 public:

  Hbase_taoAssocRangeGet_result() {
  }

  virtual ~Hbase_taoAssocRangeGet_result() throw() {}

  std::vector<TaoAssocGetResult>  success;
  IOError io;

  _Hbase_taoAssocRangeGet_result__isset __isset;

  void __set_success(const std::vector<TaoAssocGetResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_taoAssocRangeGet_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_taoAssocRangeGet_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_taoAssocRangeGet_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_taoAssocRangeGet_presult__isset {
  _Hbase_taoAssocRangeGet_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_taoAssocRangeGet_presult__isset;

class Hbase_taoAssocRangeGet_presult {
 public:


  virtual ~Hbase_taoAssocRangeGet_presult() throw() {}

  std::vector<TaoAssocGetResult> * success;
  IOError io;

  _Hbase_taoAssocRangeGet_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_taoAssocGet_args__isset {
  _Hbase_taoAssocGet_args__isset() : tableName(false), assocType(false), id1(false), id2s(false) {}
  bool tableName;
  bool assocType;
  bool id1;
  bool id2s;
} _Hbase_taoAssocGet_args__isset;

class Hbase_taoAssocGet_args {
 public:

  Hbase_taoAssocGet_args() : tableName(""), assocType(0), id1(0) {
  }

  virtual ~Hbase_taoAssocGet_args() throw() {}

  Text tableName;
  int64_t assocType;
  int64_t id1;
  std::vector<int64_t>  id2s;

  _Hbase_taoAssocGet_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_assocType(const int64_t val) {
    assocType = val;
  }

  void __set_id1(const int64_t val) {
    id1 = val;
  }

  void __set_id2s(const std::vector<int64_t> & val) {
    id2s = val;
  }

  bool operator == (const Hbase_taoAssocGet_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(assocType == rhs.assocType))
      return false;
    if (!(id1 == rhs.id1))
      return false;
    if (!(id2s == rhs.id2s))
      return false;
    return true;
  }
  bool operator != (const Hbase_taoAssocGet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_taoAssocGet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_taoAssocGet_pargs {
 public:


  virtual ~Hbase_taoAssocGet_pargs() throw() {}

  const Text* tableName;
  const int64_t* assocType;
  const int64_t* id1;
  const std::vector<int64_t> * id2s;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_taoAssocGet_result__isset {
  _Hbase_taoAssocGet_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_taoAssocGet_result__isset;

class Hbase_taoAssocGet_result {
 public:

  Hbase_taoAssocGet_result() {
  }

  virtual ~Hbase_taoAssocGet_result() throw() {}

  std::vector<TaoAssocGetResult>  success;
  IOError io;

  _Hbase_taoAssocGet_result__isset __isset;

  void __set_success(const std::vector<TaoAssocGetResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_taoAssocGet_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_taoAssocGet_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_taoAssocGet_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_taoAssocGet_presult__isset {
  _Hbase_taoAssocGet_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_taoAssocGet_presult__isset;

class Hbase_taoAssocGet_presult {
 public:


  virtual ~Hbase_taoAssocGet_presult() throw() {}

  std::vector<TaoAssocGetResult> * success;
  IOError io;

  _Hbase_taoAssocGet_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_taoAssocCount_args__isset {
  _Hbase_taoAssocCount_args__isset() : tableName(false), assocType(false), id1(false) {}
  bool tableName;
  bool assocType;
  bool id1;
} _Hbase_taoAssocCount_args__isset;

class Hbase_taoAssocCount_args {
 public:

  Hbase_taoAssocCount_args() : tableName(""), assocType(0), id1(0) {
  }

  virtual ~Hbase_taoAssocCount_args() throw() {}

  Text tableName;
  int64_t assocType;
  int64_t id1;

  _Hbase_taoAssocCount_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_assocType(const int64_t val) {
    assocType = val;
  }

  void __set_id1(const int64_t val) {
    id1 = val;
  }

  bool operator == (const Hbase_taoAssocCount_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(assocType == rhs.assocType))
      return false;
    if (!(id1 == rhs.id1))
      return false;
    return true;
  }
  bool operator != (const Hbase_taoAssocCount_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_taoAssocCount_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_taoAssocCount_pargs {
 public:


  virtual ~Hbase_taoAssocCount_pargs() throw() {}

  const Text* tableName;
  const int64_t* assocType;
  const int64_t* id1;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_taoAssocCount_result__isset {
  _Hbase_taoAssocCount_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_taoAssocCount_result__isset;

class Hbase_taoAssocCount_result {
 public:

  Hbase_taoAssocCount_result() : success(0) {
  }

  virtual ~Hbase_taoAssocCount_result() throw() {}

  int64_t success;
  IOError io;

  _Hbase_taoAssocCount_result__isset __isset;

  void __set_success(const int64_t val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_taoAssocCount_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_taoAssocCount_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_taoAssocCount_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_taoAssocCount_presult__isset {
  _Hbase_taoAssocCount_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_taoAssocCount_presult__isset;

class Hbase_taoAssocCount_presult {
 public:


  virtual ~Hbase_taoAssocCount_presult() throw() {}

  int64_t* success;
  IOError io;

  _Hbase_taoAssocCount_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithScan_args__isset {
  _Hbase_scannerOpenWithScan_args__isset() : tableName(false), scan(false) {}
  bool tableName;
  bool scan;
} _Hbase_scannerOpenWithScan_args__isset;

class Hbase_scannerOpenWithScan_args {
 public:

  Hbase_scannerOpenWithScan_args() : tableName("") {
  }

  virtual ~Hbase_scannerOpenWithScan_args() throw() {}

  Text tableName;
  TScan scan;

  _Hbase_scannerOpenWithScan_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_scan(const TScan& val) {
    scan = val;
  }

  bool operator == (const Hbase_scannerOpenWithScan_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(scan == rhs.scan))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithScan_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithScan_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithScan_pargs {
 public:


  virtual ~Hbase_scannerOpenWithScan_pargs() throw() {}

  const Text* tableName;
  const TScan* scan;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithScan_result__isset {
  _Hbase_scannerOpenWithScan_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithScan_result__isset;

class Hbase_scannerOpenWithScan_result {
 public:

  Hbase_scannerOpenWithScan_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithScan_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithScan_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithScan_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithScan_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithScan_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithScan_presult__isset {
  _Hbase_scannerOpenWithScan_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithScan_presult__isset;

class Hbase_scannerOpenWithScan_presult {
 public:


  virtual ~Hbase_scannerOpenWithScan_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithScan_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpen_args__isset {
  _Hbase_scannerOpen_args__isset() : tableName(false), startRow(false), columns(false) {}
  bool tableName;
  bool startRow;
  bool columns;
} _Hbase_scannerOpen_args__isset;

class Hbase_scannerOpen_args {
 public:

  Hbase_scannerOpen_args() : tableName(""), startRow("") {
  }

  virtual ~Hbase_scannerOpen_args() throw() {}

  Text tableName;
  Text startRow;
  std::vector<Text>  columns;

  _Hbase_scannerOpen_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  bool operator == (const Hbase_scannerOpen_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpen_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpen_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpen_pargs {
 public:


  virtual ~Hbase_scannerOpen_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const std::vector<Text> * columns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpen_result__isset {
  _Hbase_scannerOpen_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpen_result__isset;

class Hbase_scannerOpen_result {
 public:

  Hbase_scannerOpen_result() : success(0) {
  }

  virtual ~Hbase_scannerOpen_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpen_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpen_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpen_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpen_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpen_presult__isset {
  _Hbase_scannerOpen_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpen_presult__isset;

class Hbase_scannerOpen_presult {
 public:


  virtual ~Hbase_scannerOpen_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpen_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenTs_args__isset {
  _Hbase_scannerOpenTs_args__isset() : tableName(false), startRow(false), columns(false), timestamp(false) {}
  bool tableName;
  bool startRow;
  bool columns;
  bool timestamp;
} _Hbase_scannerOpenTs_args__isset;

class Hbase_scannerOpenTs_args {
 public:

  Hbase_scannerOpenTs_args() : tableName(""), startRow(""), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenTs_args() throw() {}

  Text tableName;
  Text startRow;
  std::vector<Text>  columns;
  int64_t timestamp;

  _Hbase_scannerOpenTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_scannerOpenTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenTs_pargs {
 public:


  virtual ~Hbase_scannerOpenTs_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const std::vector<Text> * columns;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenTs_result__isset {
  _Hbase_scannerOpenTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenTs_result__isset;

class Hbase_scannerOpenTs_result {
 public:

  Hbase_scannerOpenTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenTs_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenTs_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenTs_presult__isset {
  _Hbase_scannerOpenTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenTs_presult__isset;

class Hbase_scannerOpenTs_presult {
 public:


  virtual ~Hbase_scannerOpenTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithPrefix_args__isset {
  _Hbase_scannerOpenWithPrefix_args__isset() : tableName(false), startAndPrefix(false), columns(false) {}
  bool tableName;
  bool startAndPrefix;
  bool columns;
} _Hbase_scannerOpenWithPrefix_args__isset;

class Hbase_scannerOpenWithPrefix_args {
 public:

  Hbase_scannerOpenWithPrefix_args() : tableName(""), startAndPrefix("") {
  }

  virtual ~Hbase_scannerOpenWithPrefix_args() throw() {}

  Text tableName;
  Text startAndPrefix;
  std::vector<Text>  columns;

  _Hbase_scannerOpenWithPrefix_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startAndPrefix(const Text& val) {
    startAndPrefix = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  bool operator == (const Hbase_scannerOpenWithPrefix_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startAndPrefix == rhs.startAndPrefix))
      return false;
    if (!(columns == rhs.columns))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithPrefix_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithPrefix_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithPrefix_pargs {
 public:


  virtual ~Hbase_scannerOpenWithPrefix_pargs() throw() {}

  const Text* tableName;
  const Text* startAndPrefix;
  const std::vector<Text> * columns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithPrefix_result__isset {
  _Hbase_scannerOpenWithPrefix_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithPrefix_result__isset;

class Hbase_scannerOpenWithPrefix_result {
 public:

  Hbase_scannerOpenWithPrefix_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithPrefix_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithPrefix_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithPrefix_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithPrefix_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithPrefix_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithPrefix_presult__isset {
  _Hbase_scannerOpenWithPrefix_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithPrefix_presult__isset;

class Hbase_scannerOpenWithPrefix_presult {
 public:


  virtual ~Hbase_scannerOpenWithPrefix_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithPrefix_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithPrefixTs_args__isset {
  _Hbase_scannerOpenWithPrefixTs_args__isset() : tableName(false), startAndPrefix(false), columns(false), timestamp(false) {}
  bool tableName;
  bool startAndPrefix;
  bool columns;
  bool timestamp;
} _Hbase_scannerOpenWithPrefixTs_args__isset;

class Hbase_scannerOpenWithPrefixTs_args {
 public:

  Hbase_scannerOpenWithPrefixTs_args() : tableName(""), startAndPrefix(""), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenWithPrefixTs_args() throw() {}

  Text tableName;
  Text startAndPrefix;
  std::vector<Text>  columns;
  int64_t timestamp;

  _Hbase_scannerOpenWithPrefixTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startAndPrefix(const Text& val) {
    startAndPrefix = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_scannerOpenWithPrefixTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startAndPrefix == rhs.startAndPrefix))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithPrefixTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithPrefixTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithPrefixTs_pargs {
 public:


  virtual ~Hbase_scannerOpenWithPrefixTs_pargs() throw() {}

  const Text* tableName;
  const Text* startAndPrefix;
  const std::vector<Text> * columns;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithPrefixTs_result__isset {
  _Hbase_scannerOpenWithPrefixTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithPrefixTs_result__isset;

class Hbase_scannerOpenWithPrefixTs_result {
 public:

  Hbase_scannerOpenWithPrefixTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithPrefixTs_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithPrefixTs_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithPrefixTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithPrefixTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithPrefixTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithPrefixTs_presult__isset {
  _Hbase_scannerOpenWithPrefixTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithPrefixTs_presult__isset;

class Hbase_scannerOpenWithPrefixTs_presult {
 public:


  virtual ~Hbase_scannerOpenWithPrefixTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithPrefixTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithStop_args__isset {
  _Hbase_scannerOpenWithStop_args__isset() : tableName(false), startRow(false), stopRow(false), columns(false) {}
  bool tableName;
  bool startRow;
  bool stopRow;
  bool columns;
} _Hbase_scannerOpenWithStop_args__isset;

class Hbase_scannerOpenWithStop_args {
 public:

  Hbase_scannerOpenWithStop_args() : tableName(""), startRow(""), stopRow("") {
  }

  virtual ~Hbase_scannerOpenWithStop_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  std::vector<Text>  columns;

  _Hbase_scannerOpenWithStop_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_stopRow(const Text& val) {
    stopRow = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  bool operator == (const Hbase_scannerOpenWithStop_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStop_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStop_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithStop_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStop_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const std::vector<Text> * columns;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStop_result__isset {
  _Hbase_scannerOpenWithStop_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStop_result__isset;

class Hbase_scannerOpenWithStop_result {
 public:

  Hbase_scannerOpenWithStop_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStop_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStop_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithStop_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStop_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStop_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStop_presult__isset {
  _Hbase_scannerOpenWithStop_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStop_presult__isset;

class Hbase_scannerOpenWithStop_presult {
 public:


  virtual ~Hbase_scannerOpenWithStop_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStop_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithStopTs_args__isset {
  _Hbase_scannerOpenWithStopTs_args__isset() : tableName(false), startRow(false), stopRow(false), columns(false), timestamp(false) {}
  bool tableName;
  bool startRow;
  bool stopRow;
  bool columns;
  bool timestamp;
} _Hbase_scannerOpenWithStopTs_args__isset;

class Hbase_scannerOpenWithStopTs_args {
 public:

  Hbase_scannerOpenWithStopTs_args() : tableName(""), startRow(""), stopRow(""), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenWithStopTs_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  std::vector<Text>  columns;
  int64_t timestamp;

  _Hbase_scannerOpenWithStopTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_stopRow(const Text& val) {
    stopRow = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithStopTs_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStopTs_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const std::vector<Text> * columns;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopTs_result__isset {
  _Hbase_scannerOpenWithStopTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopTs_result__isset;

class Hbase_scannerOpenWithStopTs_result {
 public:

  Hbase_scannerOpenWithStopTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStopTs_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStopTs_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopTs_presult__isset {
  _Hbase_scannerOpenWithStopTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopTs_presult__isset;

class Hbase_scannerOpenWithStopTs_presult {
 public:


  virtual ~Hbase_scannerOpenWithStopTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStopTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithColumnPrefix_args__isset {
  _Hbase_scannerOpenWithColumnPrefix_args__isset() : tableName(false), ColumnPrefix(false) {}
  bool tableName;
  bool ColumnPrefix;
} _Hbase_scannerOpenWithColumnPrefix_args__isset;

class Hbase_scannerOpenWithColumnPrefix_args {
 public:

  Hbase_scannerOpenWithColumnPrefix_args() : tableName(""), ColumnPrefix("") {
  }

  virtual ~Hbase_scannerOpenWithColumnPrefix_args() throw() {}

  Text tableName;
  Text ColumnPrefix;

  _Hbase_scannerOpenWithColumnPrefix_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_ColumnPrefix(const Text& val) {
    ColumnPrefix = val;
  }

  bool operator == (const Hbase_scannerOpenWithColumnPrefix_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(ColumnPrefix == rhs.ColumnPrefix))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithColumnPrefix_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithColumnPrefix_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithColumnPrefix_pargs {
 public:


  virtual ~Hbase_scannerOpenWithColumnPrefix_pargs() throw() {}

  const Text* tableName;
  const Text* ColumnPrefix;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithColumnPrefix_result__isset {
  _Hbase_scannerOpenWithColumnPrefix_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithColumnPrefix_result__isset;

class Hbase_scannerOpenWithColumnPrefix_result {
 public:

  Hbase_scannerOpenWithColumnPrefix_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithColumnPrefix_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithColumnPrefix_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithColumnPrefix_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithColumnPrefix_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithColumnPrefix_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithColumnPrefix_presult__isset {
  _Hbase_scannerOpenWithColumnPrefix_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithColumnPrefix_presult__isset;

class Hbase_scannerOpenWithColumnPrefix_presult {
 public:


  virtual ~Hbase_scannerOpenWithColumnPrefix_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithColumnPrefix_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithColumnPrefixTs_args__isset {
  _Hbase_scannerOpenWithColumnPrefixTs_args__isset() : tableName(false), ColumnPrefix(false), timestamp(false) {}
  bool tableName;
  bool ColumnPrefix;
  bool timestamp;
} _Hbase_scannerOpenWithColumnPrefixTs_args__isset;

class Hbase_scannerOpenWithColumnPrefixTs_args {
 public:

  Hbase_scannerOpenWithColumnPrefixTs_args() : tableName(""), ColumnPrefix(""), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenWithColumnPrefixTs_args() throw() {}

  Text tableName;
  Text ColumnPrefix;
  int64_t timestamp;

  _Hbase_scannerOpenWithColumnPrefixTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_ColumnPrefix(const Text& val) {
    ColumnPrefix = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_scannerOpenWithColumnPrefixTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(ColumnPrefix == rhs.ColumnPrefix))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithColumnPrefixTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithColumnPrefixTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithColumnPrefixTs_pargs {
 public:


  virtual ~Hbase_scannerOpenWithColumnPrefixTs_pargs() throw() {}

  const Text* tableName;
  const Text* ColumnPrefix;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithColumnPrefixTs_result__isset {
  _Hbase_scannerOpenWithColumnPrefixTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithColumnPrefixTs_result__isset;

class Hbase_scannerOpenWithColumnPrefixTs_result {
 public:

  Hbase_scannerOpenWithColumnPrefixTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithColumnPrefixTs_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithColumnPrefixTs_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithColumnPrefixTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithColumnPrefixTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithColumnPrefixTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithColumnPrefixTs_presult__isset {
  _Hbase_scannerOpenWithColumnPrefixTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithColumnPrefixTs_presult__isset;

class Hbase_scannerOpenWithColumnPrefixTs_presult {
 public:


  virtual ~Hbase_scannerOpenWithColumnPrefixTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithColumnPrefixTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithStopAndColumnPrefix_args__isset {
  _Hbase_scannerOpenWithStopAndColumnPrefix_args__isset() : tableName(false), startRow(false), stopRow(false), ColumnPrefix(false) {}
  bool tableName;
  bool startRow;
  bool stopRow;
  bool ColumnPrefix;
} _Hbase_scannerOpenWithStopAndColumnPrefix_args__isset;

class Hbase_scannerOpenWithStopAndColumnPrefix_args {
 public:

  Hbase_scannerOpenWithStopAndColumnPrefix_args() : tableName(""), startRow(""), stopRow(""), ColumnPrefix("") {
  }

  virtual ~Hbase_scannerOpenWithStopAndColumnPrefix_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  Text ColumnPrefix;

  _Hbase_scannerOpenWithStopAndColumnPrefix_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_stopRow(const Text& val) {
    stopRow = val;
  }

  void __set_ColumnPrefix(const Text& val) {
    ColumnPrefix = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndColumnPrefix_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(ColumnPrefix == rhs.ColumnPrefix))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndColumnPrefix_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndColumnPrefix_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithStopAndColumnPrefix_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStopAndColumnPrefix_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const Text* ColumnPrefix;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndColumnPrefix_result__isset {
  _Hbase_scannerOpenWithStopAndColumnPrefix_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndColumnPrefix_result__isset;

class Hbase_scannerOpenWithStopAndColumnPrefix_result {
 public:

  Hbase_scannerOpenWithStopAndColumnPrefix_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStopAndColumnPrefix_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStopAndColumnPrefix_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndColumnPrefix_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndColumnPrefix_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndColumnPrefix_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndColumnPrefix_presult__isset {
  _Hbase_scannerOpenWithStopAndColumnPrefix_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndColumnPrefix_presult__isset;

class Hbase_scannerOpenWithStopAndColumnPrefix_presult {
 public:


  virtual ~Hbase_scannerOpenWithStopAndColumnPrefix_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStopAndColumnPrefix_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithStopAndColumnPrefixTs_args__isset {
  _Hbase_scannerOpenWithStopAndColumnPrefixTs_args__isset() : tableName(false), startRow(false), stopRow(false), ColumnPrefix(false), timestamp(false) {}
  bool tableName;
  bool startRow;
  bool stopRow;
  bool ColumnPrefix;
  bool timestamp;
} _Hbase_scannerOpenWithStopAndColumnPrefixTs_args__isset;

class Hbase_scannerOpenWithStopAndColumnPrefixTs_args {
 public:

  Hbase_scannerOpenWithStopAndColumnPrefixTs_args() : tableName(""), startRow(""), stopRow(""), ColumnPrefix(""), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenWithStopAndColumnPrefixTs_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  Text ColumnPrefix;
  int64_t timestamp;

  _Hbase_scannerOpenWithStopAndColumnPrefixTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_stopRow(const Text& val) {
    stopRow = val;
  }

  void __set_ColumnPrefix(const Text& val) {
    ColumnPrefix = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndColumnPrefixTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(ColumnPrefix == rhs.ColumnPrefix))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndColumnPrefixTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndColumnPrefixTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithStopAndColumnPrefixTs_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStopAndColumnPrefixTs_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const Text* ColumnPrefix;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndColumnPrefixTs_result__isset {
  _Hbase_scannerOpenWithStopAndColumnPrefixTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndColumnPrefixTs_result__isset;

class Hbase_scannerOpenWithStopAndColumnPrefixTs_result {
 public:

  Hbase_scannerOpenWithStopAndColumnPrefixTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStopAndColumnPrefixTs_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStopAndColumnPrefixTs_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndColumnPrefixTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndColumnPrefixTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndColumnPrefixTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndColumnPrefixTs_presult__isset {
  _Hbase_scannerOpenWithStopAndColumnPrefixTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndColumnPrefixTs_presult__isset;

class Hbase_scannerOpenWithStopAndColumnPrefixTs_presult {
 public:


  virtual ~Hbase_scannerOpenWithStopAndColumnPrefixTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStopAndColumnPrefixTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithMultipleColumnPrefixes_args__isset {
  _Hbase_scannerOpenWithMultipleColumnPrefixes_args__isset() : tableName(false), families(false), columnPrefixes(false) {}
  bool tableName;
  bool families;
  bool columnPrefixes;
} _Hbase_scannerOpenWithMultipleColumnPrefixes_args__isset;

class Hbase_scannerOpenWithMultipleColumnPrefixes_args {
 public:

  Hbase_scannerOpenWithMultipleColumnPrefixes_args() : tableName("") {
  }

  virtual ~Hbase_scannerOpenWithMultipleColumnPrefixes_args() throw() {}

  Text tableName;
  std::vector<Text>  families;
  std::vector<Text>  columnPrefixes;

  _Hbase_scannerOpenWithMultipleColumnPrefixes_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_families(const std::vector<Text> & val) {
    families = val;
  }

  void __set_columnPrefixes(const std::vector<Text> & val) {
    columnPrefixes = val;
  }

  bool operator == (const Hbase_scannerOpenWithMultipleColumnPrefixes_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(families == rhs.families))
      return false;
    if (!(columnPrefixes == rhs.columnPrefixes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithMultipleColumnPrefixes_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithMultipleColumnPrefixes_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithMultipleColumnPrefixes_pargs {
 public:


  virtual ~Hbase_scannerOpenWithMultipleColumnPrefixes_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * families;
  const std::vector<Text> * columnPrefixes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithMultipleColumnPrefixes_result__isset {
  _Hbase_scannerOpenWithMultipleColumnPrefixes_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithMultipleColumnPrefixes_result__isset;

class Hbase_scannerOpenWithMultipleColumnPrefixes_result {
 public:

  Hbase_scannerOpenWithMultipleColumnPrefixes_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithMultipleColumnPrefixes_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithMultipleColumnPrefixes_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithMultipleColumnPrefixes_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithMultipleColumnPrefixes_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithMultipleColumnPrefixes_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithMultipleColumnPrefixes_presult__isset {
  _Hbase_scannerOpenWithMultipleColumnPrefixes_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithMultipleColumnPrefixes_presult__isset;

class Hbase_scannerOpenWithMultipleColumnPrefixes_presult {
 public:


  virtual ~Hbase_scannerOpenWithMultipleColumnPrefixes_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithMultipleColumnPrefixes_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithMultipleColumnPrefixesTs_args__isset {
  _Hbase_scannerOpenWithMultipleColumnPrefixesTs_args__isset() : tableName(false), families(false), columnPrefixes(false), timestamp(false) {}
  bool tableName;
  bool families;
  bool columnPrefixes;
  bool timestamp;
} _Hbase_scannerOpenWithMultipleColumnPrefixesTs_args__isset;

class Hbase_scannerOpenWithMultipleColumnPrefixesTs_args {
 public:

  Hbase_scannerOpenWithMultipleColumnPrefixesTs_args() : tableName(""), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenWithMultipleColumnPrefixesTs_args() throw() {}

  Text tableName;
  std::vector<Text>  families;
  std::vector<Text>  columnPrefixes;
  int64_t timestamp;

  _Hbase_scannerOpenWithMultipleColumnPrefixesTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_families(const std::vector<Text> & val) {
    families = val;
  }

  void __set_columnPrefixes(const std::vector<Text> & val) {
    columnPrefixes = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_scannerOpenWithMultipleColumnPrefixesTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(families == rhs.families))
      return false;
    if (!(columnPrefixes == rhs.columnPrefixes))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithMultipleColumnPrefixesTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithMultipleColumnPrefixesTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithMultipleColumnPrefixesTs_pargs {
 public:


  virtual ~Hbase_scannerOpenWithMultipleColumnPrefixesTs_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * families;
  const std::vector<Text> * columnPrefixes;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithMultipleColumnPrefixesTs_result__isset {
  _Hbase_scannerOpenWithMultipleColumnPrefixesTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithMultipleColumnPrefixesTs_result__isset;

class Hbase_scannerOpenWithMultipleColumnPrefixesTs_result {
 public:

  Hbase_scannerOpenWithMultipleColumnPrefixesTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithMultipleColumnPrefixesTs_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithMultipleColumnPrefixesTs_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithMultipleColumnPrefixesTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithMultipleColumnPrefixesTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithMultipleColumnPrefixesTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithMultipleColumnPrefixesTs_presult__isset {
  _Hbase_scannerOpenWithMultipleColumnPrefixesTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithMultipleColumnPrefixesTs_presult__isset;

class Hbase_scannerOpenWithMultipleColumnPrefixesTs_presult {
 public:


  virtual ~Hbase_scannerOpenWithMultipleColumnPrefixesTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithMultipleColumnPrefixesTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_args__isset {
  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_args__isset() : tableName(false), startRow(false), stopRow(false), families(false), columnPrefixes(false) {}
  bool tableName;
  bool startRow;
  bool stopRow;
  bool families;
  bool columnPrefixes;
} _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_args__isset;

class Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_args {
 public:

  Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_args() : tableName(""), startRow(""), stopRow("") {
  }

  virtual ~Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  std::vector<Text>  families;
  std::vector<Text>  columnPrefixes;

  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_stopRow(const Text& val) {
    stopRow = val;
  }

  void __set_families(const std::vector<Text> & val) {
    families = val;
  }

  void __set_columnPrefixes(const std::vector<Text> & val) {
    columnPrefixes = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(families == rhs.families))
      return false;
    if (!(columnPrefixes == rhs.columnPrefixes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const std::vector<Text> * families;
  const std::vector<Text> * columnPrefixes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_result__isset {
  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_result__isset;

class Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_result {
 public:

  Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_presult__isset {
  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_presult__isset;

class Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_presult {
 public:


  virtual ~Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixes_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_args__isset {
  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_args__isset() : tableName(false), startRow(false), stopRow(false), families(false), columnPrefixes(false), timestamp(false) {}
  bool tableName;
  bool startRow;
  bool stopRow;
  bool families;
  bool columnPrefixes;
  bool timestamp;
} _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_args__isset;

class Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_args {
 public:

  Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_args() : tableName(""), startRow(""), stopRow(""), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  std::vector<Text>  families;
  std::vector<Text>  columnPrefixes;
  int64_t timestamp;

  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_stopRow(const Text& val) {
    stopRow = val;
  }

  void __set_families(const std::vector<Text> & val) {
    families = val;
  }

  void __set_columnPrefixes(const std::vector<Text> & val) {
    columnPrefixes = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(families == rhs.families))
      return false;
    if (!(columnPrefixes == rhs.columnPrefixes))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const std::vector<Text> * families;
  const std::vector<Text> * columnPrefixes;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_result__isset {
  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_result__isset;

class Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_result {
 public:

  Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_presult__isset {
  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_presult__isset;

class Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_presult {
 public:


  virtual ~Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStopAndMultipleColumnPrefixesTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerGet_args__isset {
  _Hbase_scannerGet_args__isset() : id(false) {}
  bool id;
} _Hbase_scannerGet_args__isset;

class Hbase_scannerGet_args {
 public:

  Hbase_scannerGet_args() : id(0) {
  }

  virtual ~Hbase_scannerGet_args() throw() {}

  ScannerID id;

  _Hbase_scannerGet_args__isset __isset;

  void __set_id(const ScannerID val) {
    id = val;
  }

  bool operator == (const Hbase_scannerGet_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerGet_pargs {
 public:


  virtual ~Hbase_scannerGet_pargs() throw() {}

  const ScannerID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerGet_result__isset {
  _Hbase_scannerGet_result__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_scannerGet_result__isset;

class Hbase_scannerGet_result {
 public:

  Hbase_scannerGet_result() {
  }

  virtual ~Hbase_scannerGet_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGet_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_scannerGet_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGet_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGet_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerGet_presult__isset {
  _Hbase_scannerGet_presult__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_scannerGet_presult__isset;

class Hbase_scannerGet_presult {
 public:


  virtual ~Hbase_scannerGet_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGet_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerGetList_args__isset {
  _Hbase_scannerGetList_args__isset() : id(false), nbRows(false) {}
  bool id;
  bool nbRows;
} _Hbase_scannerGetList_args__isset;

class Hbase_scannerGetList_args {
 public:

  Hbase_scannerGetList_args() : id(0), nbRows(0) {
  }

  virtual ~Hbase_scannerGetList_args() throw() {}

  ScannerID id;
  int32_t nbRows;

  _Hbase_scannerGetList_args__isset __isset;

  void __set_id(const ScannerID val) {
    id = val;
  }

  void __set_nbRows(const int32_t val) {
    nbRows = val;
  }

  bool operator == (const Hbase_scannerGetList_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(nbRows == rhs.nbRows))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGetList_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGetList_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerGetList_pargs {
 public:


  virtual ~Hbase_scannerGetList_pargs() throw() {}

  const ScannerID* id;
  const int32_t* nbRows;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerGetList_result__isset {
  _Hbase_scannerGetList_result__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_scannerGetList_result__isset;

class Hbase_scannerGetList_result {
 public:

  Hbase_scannerGetList_result() {
  }

  virtual ~Hbase_scannerGetList_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGetList_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_scannerGetList_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGetList_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGetList_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerGetList_presult__isset {
  _Hbase_scannerGetList_presult__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_scannerGetList_presult__isset;

class Hbase_scannerGetList_presult {
 public:


  virtual ~Hbase_scannerGetList_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGetList_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerClose_args__isset {
  _Hbase_scannerClose_args__isset() : id(false) {}
  bool id;
} _Hbase_scannerClose_args__isset;

class Hbase_scannerClose_args {
 public:

  Hbase_scannerClose_args() : id(0) {
  }

  virtual ~Hbase_scannerClose_args() throw() {}

  ScannerID id;

  _Hbase_scannerClose_args__isset __isset;

  void __set_id(const ScannerID val) {
    id = val;
  }

  bool operator == (const Hbase_scannerClose_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerClose_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerClose_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerClose_pargs {
 public:


  virtual ~Hbase_scannerClose_pargs() throw() {}

  const ScannerID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerClose_result__isset {
  _Hbase_scannerClose_result__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_scannerClose_result__isset;

class Hbase_scannerClose_result {
 public:

  Hbase_scannerClose_result() {
  }

  virtual ~Hbase_scannerClose_result() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_scannerClose_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_scannerClose_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerClose_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerClose_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerClose_presult__isset {
  _Hbase_scannerClose_presult__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_scannerClose_presult__isset;

class Hbase_scannerClose_presult {
 public:


  virtual ~Hbase_scannerClose_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_scannerClose_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowOrBefore_args__isset {
  _Hbase_getRowOrBefore_args__isset() : tableName(false), row(false), family(false) {}
  bool tableName;
  bool row;
  bool family;
} _Hbase_getRowOrBefore_args__isset;

class Hbase_getRowOrBefore_args {
 public:

  Hbase_getRowOrBefore_args() : tableName(""), row(""), family("") {
  }

  virtual ~Hbase_getRowOrBefore_args() throw() {}

  Text tableName;
  Text row;
  Text family;

  _Hbase_getRowOrBefore_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_family(const Text& val) {
    family = val;
  }

  bool operator == (const Hbase_getRowOrBefore_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(family == rhs.family))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowOrBefore_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowOrBefore_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowOrBefore_pargs {
 public:


  virtual ~Hbase_getRowOrBefore_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* family;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowOrBefore_result__isset {
  _Hbase_getRowOrBefore_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowOrBefore_result__isset;

class Hbase_getRowOrBefore_result {
 public:

  Hbase_getRowOrBefore_result() {
  }

  virtual ~Hbase_getRowOrBefore_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  _Hbase_getRowOrBefore_result__isset __isset;

  void __set_success(const std::vector<TCell> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowOrBefore_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowOrBefore_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowOrBefore_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowOrBefore_presult__isset {
  _Hbase_getRowOrBefore_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowOrBefore_presult__isset;

class Hbase_getRowOrBefore_presult {
 public:


  virtual ~Hbase_getRowOrBefore_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  _Hbase_getRowOrBefore_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRegionInfo_args__isset {
  _Hbase_getRegionInfo_args__isset() : row(false) {}
  bool row;
} _Hbase_getRegionInfo_args__isset;

class Hbase_getRegionInfo_args {
 public:

  Hbase_getRegionInfo_args() : row("") {
  }

  virtual ~Hbase_getRegionInfo_args() throw() {}

  Text row;

  _Hbase_getRegionInfo_args__isset __isset;

  void __set_row(const Text& val) {
    row = val;
  }

  bool operator == (const Hbase_getRegionInfo_args & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRegionInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRegionInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRegionInfo_pargs {
 public:


  virtual ~Hbase_getRegionInfo_pargs() throw() {}

  const Text* row;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRegionInfo_result__isset {
  _Hbase_getRegionInfo_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRegionInfo_result__isset;

class Hbase_getRegionInfo_result {
 public:

  Hbase_getRegionInfo_result() {
  }

  virtual ~Hbase_getRegionInfo_result() throw() {}

  TRegionInfo success;
  IOError io;

  _Hbase_getRegionInfo_result__isset __isset;

  void __set_success(const TRegionInfo& val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRegionInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRegionInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRegionInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRegionInfo_presult__isset {
  _Hbase_getRegionInfo_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRegionInfo_presult__isset;

class Hbase_getRegionInfo_presult {
 public:


  virtual ~Hbase_getRegionInfo_presult() throw() {}

  TRegionInfo* success;
  IOError io;

  _Hbase_getRegionInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithFilterString_args__isset {
  _Hbase_scannerOpenWithFilterString_args__isset() : tableName(false), filterString(false) {}
  bool tableName;
  bool filterString;
} _Hbase_scannerOpenWithFilterString_args__isset;

class Hbase_scannerOpenWithFilterString_args {
 public:

  Hbase_scannerOpenWithFilterString_args() : tableName(""), filterString("") {
  }

  virtual ~Hbase_scannerOpenWithFilterString_args() throw() {}

  Text tableName;
  Text filterString;

  _Hbase_scannerOpenWithFilterString_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_filterString(const Text& val) {
    filterString = val;
  }

  bool operator == (const Hbase_scannerOpenWithFilterString_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(filterString == rhs.filterString))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithFilterString_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithFilterString_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithFilterString_pargs {
 public:


  virtual ~Hbase_scannerOpenWithFilterString_pargs() throw() {}

  const Text* tableName;
  const Text* filterString;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithFilterString_result__isset {
  _Hbase_scannerOpenWithFilterString_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithFilterString_result__isset;

class Hbase_scannerOpenWithFilterString_result {
 public:

  Hbase_scannerOpenWithFilterString_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithFilterString_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithFilterString_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithFilterString_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithFilterString_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithFilterString_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithFilterString_presult__isset {
  _Hbase_scannerOpenWithFilterString_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithFilterString_presult__isset;

class Hbase_scannerOpenWithFilterString_presult {
 public:


  virtual ~Hbase_scannerOpenWithFilterString_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithFilterString_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithFilterStringTs_args__isset {
  _Hbase_scannerOpenWithFilterStringTs_args__isset() : tableName(false), filterString(false), timestamp(false) {}
  bool tableName;
  bool filterString;
  bool timestamp;
} _Hbase_scannerOpenWithFilterStringTs_args__isset;

class Hbase_scannerOpenWithFilterStringTs_args {
 public:

  Hbase_scannerOpenWithFilterStringTs_args() : tableName(""), filterString(""), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenWithFilterStringTs_args() throw() {}

  Text tableName;
  Text filterString;
  int64_t timestamp;

  _Hbase_scannerOpenWithFilterStringTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_filterString(const Text& val) {
    filterString = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_scannerOpenWithFilterStringTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(filterString == rhs.filterString))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithFilterStringTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithFilterStringTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithFilterStringTs_pargs {
 public:


  virtual ~Hbase_scannerOpenWithFilterStringTs_pargs() throw() {}

  const Text* tableName;
  const Text* filterString;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithFilterStringTs_result__isset {
  _Hbase_scannerOpenWithFilterStringTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithFilterStringTs_result__isset;

class Hbase_scannerOpenWithFilterStringTs_result {
 public:

  Hbase_scannerOpenWithFilterStringTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithFilterStringTs_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithFilterStringTs_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithFilterStringTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithFilterStringTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithFilterStringTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithFilterStringTs_presult__isset {
  _Hbase_scannerOpenWithFilterStringTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithFilterStringTs_presult__isset;

class Hbase_scannerOpenWithFilterStringTs_presult {
 public:


  virtual ~Hbase_scannerOpenWithFilterStringTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithFilterStringTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithStopAndFilterString_args__isset {
  _Hbase_scannerOpenWithStopAndFilterString_args__isset() : tableName(false), startRow(false), stopRow(false), filterString(false) {}
  bool tableName;
  bool startRow;
  bool stopRow;
  bool filterString;
} _Hbase_scannerOpenWithStopAndFilterString_args__isset;

class Hbase_scannerOpenWithStopAndFilterString_args {
 public:

  Hbase_scannerOpenWithStopAndFilterString_args() : tableName(""), startRow(""), stopRow(""), filterString("") {
  }

  virtual ~Hbase_scannerOpenWithStopAndFilterString_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  Text filterString;

  _Hbase_scannerOpenWithStopAndFilterString_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_stopRow(const Text& val) {
    stopRow = val;
  }

  void __set_filterString(const Text& val) {
    filterString = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndFilterString_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(filterString == rhs.filterString))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndFilterString_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndFilterString_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithStopAndFilterString_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStopAndFilterString_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const Text* filterString;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndFilterString_result__isset {
  _Hbase_scannerOpenWithStopAndFilterString_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndFilterString_result__isset;

class Hbase_scannerOpenWithStopAndFilterString_result {
 public:

  Hbase_scannerOpenWithStopAndFilterString_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStopAndFilterString_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStopAndFilterString_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndFilterString_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndFilterString_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndFilterString_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndFilterString_presult__isset {
  _Hbase_scannerOpenWithStopAndFilterString_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndFilterString_presult__isset;

class Hbase_scannerOpenWithStopAndFilterString_presult {
 public:


  virtual ~Hbase_scannerOpenWithStopAndFilterString_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStopAndFilterString_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithStopAndFilterStringTs_args__isset {
  _Hbase_scannerOpenWithStopAndFilterStringTs_args__isset() : tableName(false), startRow(false), stopRow(false), filterString(false), timestamp(false) {}
  bool tableName;
  bool startRow;
  bool stopRow;
  bool filterString;
  bool timestamp;
} _Hbase_scannerOpenWithStopAndFilterStringTs_args__isset;

class Hbase_scannerOpenWithStopAndFilterStringTs_args {
 public:

  Hbase_scannerOpenWithStopAndFilterStringTs_args() : tableName(""), startRow(""), stopRow(""), filterString(""), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenWithStopAndFilterStringTs_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  Text filterString;
  int64_t timestamp;

  _Hbase_scannerOpenWithStopAndFilterStringTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_stopRow(const Text& val) {
    stopRow = val;
  }

  void __set_filterString(const Text& val) {
    filterString = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndFilterStringTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(filterString == rhs.filterString))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndFilterStringTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndFilterStringTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithStopAndFilterStringTs_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStopAndFilterStringTs_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const Text* filterString;
  const int64_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndFilterStringTs_result__isset {
  _Hbase_scannerOpenWithStopAndFilterStringTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndFilterStringTs_result__isset;

class Hbase_scannerOpenWithStopAndFilterStringTs_result {
 public:

  Hbase_scannerOpenWithStopAndFilterStringTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStopAndFilterStringTs_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStopAndFilterStringTs_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopAndFilterStringTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopAndFilterStringTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopAndFilterStringTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopAndFilterStringTs_presult__isset {
  _Hbase_scannerOpenWithStopAndFilterStringTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopAndFilterStringTs_presult__isset;

class Hbase_scannerOpenWithStopAndFilterStringTs_presult {
 public:


  virtual ~Hbase_scannerOpenWithStopAndFilterStringTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStopAndFilterStringTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class HbaseClient : virtual public HbaseIf {
 public:
  HbaseClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  HbaseClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void enableTable(const Bytes& tableName);
  void send_enableTable(const Bytes& tableName);
  void recv_enableTable();
  void disableTable(const Bytes& tableName);
  void send_disableTable(const Bytes& tableName);
  void recv_disableTable();
  bool isTableEnabled(const Bytes& tableName);
  void send_isTableEnabled(const Bytes& tableName);
  bool recv_isTableEnabled();
  void compact(const Bytes& tableNameOrRegionName);
  void send_compact(const Bytes& tableNameOrRegionName);
  void recv_compact();
  void majorCompact(const Bytes& tableNameOrRegionName);
  void send_majorCompact(const Bytes& tableNameOrRegionName);
  void recv_majorCompact();
  void getTableNames(std::vector<Text> & _return);
  void send_getTableNames();
  void recv_getTableNames(std::vector<Text> & _return);
  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName);
  void send_getColumnDescriptors(const Text& tableName);
  void recv_getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return);
  void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName);
  void send_getTableRegions(const Text& tableName);
  void recv_getTableRegions(std::vector<TRegionInfo> & _return);
  void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies);
  void send_createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies);
  void recv_createTable();
  void deleteTable(const Text& tableName);
  void send_deleteTable(const Text& tableName);
  void recv_deleteTable();
  void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column);
  void send_get(const Text& tableName, const Text& row, const Text& column);
  void recv_get(std::vector<TCell> & _return);
  void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions);
  void send_getVer(const Text& tableName, const Text& row, const Text& column, const int32_t numVersions);
  void recv_getVer(std::vector<TCell> & _return);
  void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions);
  void send_getVerTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions);
  void recv_getVerTs(std::vector<TCell> & _return);
  void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row);
  void send_getRow(const Text& tableName, const Text& row);
  void recv_getRow(std::vector<TRowResult> & _return);
  void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns);
  void send_getRowWithColumns(const Text& tableName, const Text& row, const std::vector<Text> & columns);
  void recv_getRowWithColumns(std::vector<TRowResult> & _return);
  void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp);
  void send_getRowTs(const Text& tableName, const Text& row, const int64_t timestamp);
  void recv_getRowTs(std::vector<TRowResult> & _return);
  void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp);
  void send_getRowWithColumnsTs(const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp);
  void recv_getRowWithColumnsTs(std::vector<TRowResult> & _return);
  void getRowWithColumnPrefix(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const Text& prefix);
  void send_getRowWithColumnPrefix(const Text& tableName, const Text& row, const Text& prefix);
  void recv_getRowWithColumnPrefix(std::vector<TRowResult> & _return);
  void getRowWithColumnPrefixTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const Text& prefix, const int64_t timestamp);
  void send_getRowWithColumnPrefixTs(const Text& tableName, const Text& row, const Text& prefix, const int64_t timestamp);
  void recv_getRowWithColumnPrefixTs(std::vector<TRowResult> & _return);
  void getRowWithMultipleColumnPrefixes(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes);
  void send_getRowWithMultipleColumnPrefixes(const Text& tableName, const Text& row, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes);
  void recv_getRowWithMultipleColumnPrefixes(std::vector<TRowResult> & _return);
  void getRowWithMultipleColumnPrefixesTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp);
  void send_getRowWithMultipleColumnPrefixesTs(const Text& tableName, const Text& row, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp);
  void recv_getRowWithMultipleColumnPrefixesTs(std::vector<TRowResult> & _return);
  void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows);
  void send_getRows(const Text& tableName, const std::vector<Text> & rows);
  void recv_getRows(std::vector<TRowResult> & _return);
  void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp);
  void send_getRowsTs(const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp);
  void recv_getRowsTs(std::vector<TRowResult> & _return);
  void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & families);
  void send_getRowsWithColumns(const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & families);
  void recv_getRowsWithColumns(std::vector<TRowResult> & _return);
  void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & families, const int64_t timestamp);
  void send_getRowsWithColumnsTs(const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & families, const int64_t timestamp);
  void recv_getRowsWithColumnsTs(std::vector<TRowResult> & _return);
  void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes);
  void send_mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes);
  void recv_mutateRow();
  void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_mutateRowTs();
  void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes);
  void send_mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes);
  void recv_mutateRows();
  void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_mutateRowsTs();
  bool checkAndMutateRow(const Text& tableName, const Text& row, const Text& columnCheck, const Text& valueCheck, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes);
  void send_checkAndMutateRow(const Text& tableName, const Text& row, const Text& columnCheck, const Text& valueCheck, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes);
  bool recv_checkAndMutateRow();
  bool checkAndMutateRowTs(const Text& tableName, const Text& row, const Text& columnCheck, const Text& valueCheck, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_checkAndMutateRowTs(const Text& tableName, const Text& row, const Text& columnCheck, const Text& valueCheck, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes);
  bool recv_checkAndMutateRowTs();
  int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value);
  void send_atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value);
  int64_t recv_atomicIncrement();
  void deleteAll(const Text& tableName, const Text& row, const Text& column);
  void send_deleteAll(const Text& tableName, const Text& row, const Text& column);
  void recv_deleteAll();
  void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp);
  void send_deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp);
  void recv_deleteAllTs();
  void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void send_deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void recv_deleteAllRow();
  void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp);
  void send_deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp);
  void recv_deleteAllRowTs();
  void mutateRowsAsync(const Text& tableName, const std::vector<BatchMutation> & rowBatches);
  void send_mutateRowsAsync(const Text& tableName, const std::vector<BatchMutation> & rowBatches);
  void mutateRowsTsAsync(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp);
  void send_mutateRowsTsAsync(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp);
  int64_t taoAssocPut(const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t id2, const int64_t id1Type, const int64_t id2Type, const int64_t timestamp, const AssocVisibility::type visibility, const bool update_count, const int64_t dataVersion, const Text& data, const Text& wormhole_comment);
  void send_taoAssocPut(const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t id2, const int64_t id1Type, const int64_t id2Type, const int64_t timestamp, const AssocVisibility::type visibility, const bool update_count, const int64_t dataVersion, const Text& data, const Text& wormhole_comment);
  int64_t recv_taoAssocPut();
  int64_t taoAssocDelete(const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t id2, const AssocVisibility::type visibility, const bool update_count, const Text& wormhole_comment);
  void send_taoAssocDelete(const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t id2, const AssocVisibility::type visibility, const bool update_count, const Text& wormhole_comment);
  int64_t recv_taoAssocDelete();
  void taoAssocRangeGet(std::vector<TaoAssocGetResult> & _return, const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t start_time, const int64_t end_time, const int64_t offset, const int64_t limit);
  void send_taoAssocRangeGet(const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t start_time, const int64_t end_time, const int64_t offset, const int64_t limit);
  void recv_taoAssocRangeGet(std::vector<TaoAssocGetResult> & _return);
  void taoAssocGet(std::vector<TaoAssocGetResult> & _return, const Text& tableName, const int64_t assocType, const int64_t id1, const std::vector<int64_t> & id2s);
  void send_taoAssocGet(const Text& tableName, const int64_t assocType, const int64_t id1, const std::vector<int64_t> & id2s);
  void recv_taoAssocGet(std::vector<TaoAssocGetResult> & _return);
  int64_t taoAssocCount(const Text& tableName, const int64_t assocType, const int64_t id1);
  void send_taoAssocCount(const Text& tableName, const int64_t assocType, const int64_t id1);
  int64_t recv_taoAssocCount();
  ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan);
  void send_scannerOpenWithScan(const Text& tableName, const TScan& scan);
  ScannerID recv_scannerOpenWithScan();
  ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns);
  void send_scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns);
  ScannerID recv_scannerOpen();
  ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp);
  void send_scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp);
  ScannerID recv_scannerOpenTs();
  ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns);
  void send_scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns);
  ScannerID recv_scannerOpenWithPrefix();
  ScannerID scannerOpenWithPrefixTs(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const int64_t timestamp);
  void send_scannerOpenWithPrefixTs(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const int64_t timestamp);
  ScannerID recv_scannerOpenWithPrefixTs();
  ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns);
  void send_scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns);
  ScannerID recv_scannerOpenWithStop();
  ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp);
  void send_scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp);
  ScannerID recv_scannerOpenWithStopTs();
  ScannerID scannerOpenWithColumnPrefix(const Text& tableName, const Text& ColumnPrefix);
  void send_scannerOpenWithColumnPrefix(const Text& tableName, const Text& ColumnPrefix);
  ScannerID recv_scannerOpenWithColumnPrefix();
  ScannerID scannerOpenWithColumnPrefixTs(const Text& tableName, const Text& ColumnPrefix, const int64_t timestamp);
  void send_scannerOpenWithColumnPrefixTs(const Text& tableName, const Text& ColumnPrefix, const int64_t timestamp);
  ScannerID recv_scannerOpenWithColumnPrefixTs();
  ScannerID scannerOpenWithStopAndColumnPrefix(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& ColumnPrefix);
  void send_scannerOpenWithStopAndColumnPrefix(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& ColumnPrefix);
  ScannerID recv_scannerOpenWithStopAndColumnPrefix();
  ScannerID scannerOpenWithStopAndColumnPrefixTs(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& ColumnPrefix, const int64_t timestamp);
  void send_scannerOpenWithStopAndColumnPrefixTs(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& ColumnPrefix, const int64_t timestamp);
  ScannerID recv_scannerOpenWithStopAndColumnPrefixTs();
  ScannerID scannerOpenWithMultipleColumnPrefixes(const Text& tableName, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes);
  void send_scannerOpenWithMultipleColumnPrefixes(const Text& tableName, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes);
  ScannerID recv_scannerOpenWithMultipleColumnPrefixes();
  ScannerID scannerOpenWithMultipleColumnPrefixesTs(const Text& tableName, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp);
  void send_scannerOpenWithMultipleColumnPrefixesTs(const Text& tableName, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp);
  ScannerID recv_scannerOpenWithMultipleColumnPrefixesTs();
  ScannerID scannerOpenWithStopAndMultipleColumnPrefixes(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes);
  void send_scannerOpenWithStopAndMultipleColumnPrefixes(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes);
  ScannerID recv_scannerOpenWithStopAndMultipleColumnPrefixes();
  ScannerID scannerOpenWithStopAndMultipleColumnPrefixesTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp);
  void send_scannerOpenWithStopAndMultipleColumnPrefixesTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp);
  ScannerID recv_scannerOpenWithStopAndMultipleColumnPrefixesTs();
  void scannerGet(std::vector<TRowResult> & _return, const ScannerID id);
  void send_scannerGet(const ScannerID id);
  void recv_scannerGet(std::vector<TRowResult> & _return);
  void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows);
  void send_scannerGetList(const ScannerID id, const int32_t nbRows);
  void recv_scannerGetList(std::vector<TRowResult> & _return);
  void scannerClose(const ScannerID id);
  void send_scannerClose(const ScannerID id);
  void recv_scannerClose();
  void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family);
  void send_getRowOrBefore(const Text& tableName, const Text& row, const Text& family);
  void recv_getRowOrBefore(std::vector<TCell> & _return);
  void getRegionInfo(TRegionInfo& _return, const Text& row);
  void send_getRegionInfo(const Text& row);
  void recv_getRegionInfo(TRegionInfo& _return);
  ScannerID scannerOpenWithFilterString(const Text& tableName, const Text& filterString);
  void send_scannerOpenWithFilterString(const Text& tableName, const Text& filterString);
  ScannerID recv_scannerOpenWithFilterString();
  ScannerID scannerOpenWithFilterStringTs(const Text& tableName, const Text& filterString, const int64_t timestamp);
  void send_scannerOpenWithFilterStringTs(const Text& tableName, const Text& filterString, const int64_t timestamp);
  ScannerID recv_scannerOpenWithFilterStringTs();
  ScannerID scannerOpenWithStopAndFilterString(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& filterString);
  void send_scannerOpenWithStopAndFilterString(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& filterString);
  ScannerID recv_scannerOpenWithStopAndFilterString();
  ScannerID scannerOpenWithStopAndFilterStringTs(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& filterString, const int64_t timestamp);
  void send_scannerOpenWithStopAndFilterStringTs(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& filterString, const int64_t timestamp);
  ScannerID recv_scannerOpenWithStopAndFilterStringTs();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class HbaseProcessor : public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<HbaseIf> iface_;
  virtual bool process_fn(apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid, void* callContext);
 private:
  std::map<std::string, void (HbaseProcessor::*)(int32_t, apache::thrift::protocol::TProtocol*, apache::thrift::protocol::TProtocol*, void*)> processMap_;
  void process_enableTable(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_disableTable(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_isTableEnabled(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_compact(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_majorCompact(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTableNames(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getColumnDescriptors(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTableRegions(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createTable(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteTable(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getVer(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getVerTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRow(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowWithColumns(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowWithColumnsTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowWithColumnPrefix(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowWithColumnPrefixTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowWithMultipleColumnPrefixes(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowWithMultipleColumnPrefixesTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRows(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowsTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowsWithColumns(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowsWithColumnsTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRow(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRowTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRows(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRowsTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_checkAndMutateRow(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_checkAndMutateRowTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_atomicIncrement(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAll(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAllTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAllRow(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAllRowTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRowsAsync(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRowsTsAsync(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_taoAssocPut(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_taoAssocDelete(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_taoAssocRangeGet(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_taoAssocGet(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_taoAssocCount(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithScan(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpen(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithPrefix(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithPrefixTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStop(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStopTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithColumnPrefix(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithColumnPrefixTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStopAndColumnPrefix(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStopAndColumnPrefixTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithMultipleColumnPrefixes(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithMultipleColumnPrefixesTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStopAndMultipleColumnPrefixes(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStopAndMultipleColumnPrefixesTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerGet(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerGetList(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerClose(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowOrBefore(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRegionInfo(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithFilterString(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithFilterStringTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStopAndFilterString(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStopAndFilterStringTs(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  HbaseProcessor(boost::shared_ptr<HbaseIf> iface) :
    iface_(iface) {
    processMap_["enableTable"] = &HbaseProcessor::process_enableTable;
    processMap_["disableTable"] = &HbaseProcessor::process_disableTable;
    processMap_["isTableEnabled"] = &HbaseProcessor::process_isTableEnabled;
    processMap_["compact"] = &HbaseProcessor::process_compact;
    processMap_["majorCompact"] = &HbaseProcessor::process_majorCompact;
    processMap_["getTableNames"] = &HbaseProcessor::process_getTableNames;
    processMap_["getColumnDescriptors"] = &HbaseProcessor::process_getColumnDescriptors;
    processMap_["getTableRegions"] = &HbaseProcessor::process_getTableRegions;
    processMap_["createTable"] = &HbaseProcessor::process_createTable;
    processMap_["deleteTable"] = &HbaseProcessor::process_deleteTable;
    processMap_["get"] = &HbaseProcessor::process_get;
    processMap_["getVer"] = &HbaseProcessor::process_getVer;
    processMap_["getVerTs"] = &HbaseProcessor::process_getVerTs;
    processMap_["getRow"] = &HbaseProcessor::process_getRow;
    processMap_["getRowWithColumns"] = &HbaseProcessor::process_getRowWithColumns;
    processMap_["getRowTs"] = &HbaseProcessor::process_getRowTs;
    processMap_["getRowWithColumnsTs"] = &HbaseProcessor::process_getRowWithColumnsTs;
    processMap_["getRowWithColumnPrefix"] = &HbaseProcessor::process_getRowWithColumnPrefix;
    processMap_["getRowWithColumnPrefixTs"] = &HbaseProcessor::process_getRowWithColumnPrefixTs;
    processMap_["getRowWithMultipleColumnPrefixes"] = &HbaseProcessor::process_getRowWithMultipleColumnPrefixes;
    processMap_["getRowWithMultipleColumnPrefixesTs"] = &HbaseProcessor::process_getRowWithMultipleColumnPrefixesTs;
    processMap_["getRows"] = &HbaseProcessor::process_getRows;
    processMap_["getRowsTs"] = &HbaseProcessor::process_getRowsTs;
    processMap_["getRowsWithColumns"] = &HbaseProcessor::process_getRowsWithColumns;
    processMap_["getRowsWithColumnsTs"] = &HbaseProcessor::process_getRowsWithColumnsTs;
    processMap_["mutateRow"] = &HbaseProcessor::process_mutateRow;
    processMap_["mutateRowTs"] = &HbaseProcessor::process_mutateRowTs;
    processMap_["mutateRows"] = &HbaseProcessor::process_mutateRows;
    processMap_["mutateRowsTs"] = &HbaseProcessor::process_mutateRowsTs;
    processMap_["checkAndMutateRow"] = &HbaseProcessor::process_checkAndMutateRow;
    processMap_["checkAndMutateRowTs"] = &HbaseProcessor::process_checkAndMutateRowTs;
    processMap_["atomicIncrement"] = &HbaseProcessor::process_atomicIncrement;
    processMap_["deleteAll"] = &HbaseProcessor::process_deleteAll;
    processMap_["deleteAllTs"] = &HbaseProcessor::process_deleteAllTs;
    processMap_["deleteAllRow"] = &HbaseProcessor::process_deleteAllRow;
    processMap_["deleteAllRowTs"] = &HbaseProcessor::process_deleteAllRowTs;
    processMap_["mutateRowsAsync"] = &HbaseProcessor::process_mutateRowsAsync;
    processMap_["mutateRowsTsAsync"] = &HbaseProcessor::process_mutateRowsTsAsync;
    processMap_["taoAssocPut"] = &HbaseProcessor::process_taoAssocPut;
    processMap_["taoAssocDelete"] = &HbaseProcessor::process_taoAssocDelete;
    processMap_["taoAssocRangeGet"] = &HbaseProcessor::process_taoAssocRangeGet;
    processMap_["taoAssocGet"] = &HbaseProcessor::process_taoAssocGet;
    processMap_["taoAssocCount"] = &HbaseProcessor::process_taoAssocCount;
    processMap_["scannerOpenWithScan"] = &HbaseProcessor::process_scannerOpenWithScan;
    processMap_["scannerOpen"] = &HbaseProcessor::process_scannerOpen;
    processMap_["scannerOpenTs"] = &HbaseProcessor::process_scannerOpenTs;
    processMap_["scannerOpenWithPrefix"] = &HbaseProcessor::process_scannerOpenWithPrefix;
    processMap_["scannerOpenWithPrefixTs"] = &HbaseProcessor::process_scannerOpenWithPrefixTs;
    processMap_["scannerOpenWithStop"] = &HbaseProcessor::process_scannerOpenWithStop;
    processMap_["scannerOpenWithStopTs"] = &HbaseProcessor::process_scannerOpenWithStopTs;
    processMap_["scannerOpenWithColumnPrefix"] = &HbaseProcessor::process_scannerOpenWithColumnPrefix;
    processMap_["scannerOpenWithColumnPrefixTs"] = &HbaseProcessor::process_scannerOpenWithColumnPrefixTs;
    processMap_["scannerOpenWithStopAndColumnPrefix"] = &HbaseProcessor::process_scannerOpenWithStopAndColumnPrefix;
    processMap_["scannerOpenWithStopAndColumnPrefixTs"] = &HbaseProcessor::process_scannerOpenWithStopAndColumnPrefixTs;
    processMap_["scannerOpenWithMultipleColumnPrefixes"] = &HbaseProcessor::process_scannerOpenWithMultipleColumnPrefixes;
    processMap_["scannerOpenWithMultipleColumnPrefixesTs"] = &HbaseProcessor::process_scannerOpenWithMultipleColumnPrefixesTs;
    processMap_["scannerOpenWithStopAndMultipleColumnPrefixes"] = &HbaseProcessor::process_scannerOpenWithStopAndMultipleColumnPrefixes;
    processMap_["scannerOpenWithStopAndMultipleColumnPrefixesTs"] = &HbaseProcessor::process_scannerOpenWithStopAndMultipleColumnPrefixesTs;
    processMap_["scannerGet"] = &HbaseProcessor::process_scannerGet;
    processMap_["scannerGetList"] = &HbaseProcessor::process_scannerGetList;
    processMap_["scannerClose"] = &HbaseProcessor::process_scannerClose;
    processMap_["getRowOrBefore"] = &HbaseProcessor::process_getRowOrBefore;
    processMap_["getRegionInfo"] = &HbaseProcessor::process_getRegionInfo;
    processMap_["scannerOpenWithFilterString"] = &HbaseProcessor::process_scannerOpenWithFilterString;
    processMap_["scannerOpenWithFilterStringTs"] = &HbaseProcessor::process_scannerOpenWithFilterStringTs;
    processMap_["scannerOpenWithStopAndFilterString"] = &HbaseProcessor::process_scannerOpenWithStopAndFilterString;
    processMap_["scannerOpenWithStopAndFilterStringTs"] = &HbaseProcessor::process_scannerOpenWithStopAndFilterStringTs;
  }

  virtual bool process(boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, void* callContext);
  virtual ~HbaseProcessor() {}
};

class HbaseProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  HbaseProcessorFactory(const ::boost::shared_ptr< HbaseIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< HbaseIfFactory > handlerFactory_;
};

class HbaseMultiface : virtual public HbaseIf {
 public:
  HbaseMultiface(std::vector<boost::shared_ptr<HbaseIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~HbaseMultiface() {}
 protected:
  std::vector<boost::shared_ptr<HbaseIf> > ifaces_;
  HbaseMultiface() {}
  void add(boost::shared_ptr<HbaseIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void enableTable(const Bytes& tableName) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->enableTable(tableName);
    }
  }

  void disableTable(const Bytes& tableName) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->disableTable(tableName);
    }
  }

  bool isTableEnabled(const Bytes& tableName) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->isTableEnabled(tableName);
      } else {
        ifaces_[i]->isTableEnabled(tableName);
      }
    }
  }

  void compact(const Bytes& tableNameOrRegionName) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->compact(tableNameOrRegionName);
    }
  }

  void majorCompact(const Bytes& tableNameOrRegionName) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->majorCompact(tableNameOrRegionName);
    }
  }

  void getTableNames(std::vector<Text> & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getTableNames(_return);
        return;
      } else {
        ifaces_[i]->getTableNames(_return);
      }
    }
  }

  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getColumnDescriptors(_return, tableName);
        return;
      } else {
        ifaces_[i]->getColumnDescriptors(_return, tableName);
      }
    }
  }

  void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getTableRegions(_return, tableName);
        return;
      } else {
        ifaces_[i]->getTableRegions(_return, tableName);
      }
    }
  }

  void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->createTable(tableName, columnFamilies);
    }
  }

  void deleteTable(const Text& tableName) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteTable(tableName);
    }
  }

  void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get(_return, tableName, row, column);
        return;
      } else {
        ifaces_[i]->get(_return, tableName, row, column);
      }
    }
  }

  void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getVer(_return, tableName, row, column, numVersions);
        return;
      } else {
        ifaces_[i]->getVer(_return, tableName, row, column, numVersions);
      }
    }
  }

  void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getVerTs(_return, tableName, row, column, timestamp, numVersions);
        return;
      } else {
        ifaces_[i]->getVerTs(_return, tableName, row, column, timestamp, numVersions);
      }
    }
  }

  void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRow(_return, tableName, row);
        return;
      } else {
        ifaces_[i]->getRow(_return, tableName, row);
      }
    }
  }

  void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowWithColumns(_return, tableName, row, columns);
        return;
      } else {
        ifaces_[i]->getRowWithColumns(_return, tableName, row, columns);
      }
    }
  }

  void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowTs(_return, tableName, row, timestamp);
        return;
      } else {
        ifaces_[i]->getRowTs(_return, tableName, row, timestamp);
      }
    }
  }

  void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowWithColumnsTs(_return, tableName, row, columns, timestamp);
        return;
      } else {
        ifaces_[i]->getRowWithColumnsTs(_return, tableName, row, columns, timestamp);
      }
    }
  }

  void getRowWithColumnPrefix(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const Text& prefix) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowWithColumnPrefix(_return, tableName, row, prefix);
        return;
      } else {
        ifaces_[i]->getRowWithColumnPrefix(_return, tableName, row, prefix);
      }
    }
  }

  void getRowWithColumnPrefixTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const Text& prefix, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowWithColumnPrefixTs(_return, tableName, row, prefix, timestamp);
        return;
      } else {
        ifaces_[i]->getRowWithColumnPrefixTs(_return, tableName, row, prefix, timestamp);
      }
    }
  }

  void getRowWithMultipleColumnPrefixes(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowWithMultipleColumnPrefixes(_return, tableName, row, families, columnPrefixes);
        return;
      } else {
        ifaces_[i]->getRowWithMultipleColumnPrefixes(_return, tableName, row, families, columnPrefixes);
      }
    }
  }

  void getRowWithMultipleColumnPrefixesTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowWithMultipleColumnPrefixesTs(_return, tableName, row, families, columnPrefixes, timestamp);
        return;
      } else {
        ifaces_[i]->getRowWithMultipleColumnPrefixesTs(_return, tableName, row, families, columnPrefixes, timestamp);
      }
    }
  }

  void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRows(_return, tableName, rows);
        return;
      } else {
        ifaces_[i]->getRows(_return, tableName, rows);
      }
    }
  }

  void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowsTs(_return, tableName, rows, timestamp);
        return;
      } else {
        ifaces_[i]->getRowsTs(_return, tableName, rows, timestamp);
      }
    }
  }

  void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & families) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowsWithColumns(_return, tableName, rows, families);
        return;
      } else {
        ifaces_[i]->getRowsWithColumns(_return, tableName, rows, families);
      }
    }
  }

  void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & families, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowsWithColumnsTs(_return, tableName, rows, families, timestamp);
        return;
      } else {
        ifaces_[i]->getRowsWithColumnsTs(_return, tableName, rows, families, timestamp);
      }
    }
  }

  void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->mutateRow(tableName, row, mutations, attributes);
    }
  }

  void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->mutateRowTs(tableName, row, mutations, timestamp, attributes);
    }
  }

  void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->mutateRows(tableName, rowBatches, attributes);
    }
  }

  void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->mutateRowsTs(tableName, rowBatches, timestamp, attributes);
    }
  }

  bool checkAndMutateRow(const Text& tableName, const Text& row, const Text& columnCheck, const Text& valueCheck, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->checkAndMutateRow(tableName, row, columnCheck, valueCheck, mutations, attributes);
      } else {
        ifaces_[i]->checkAndMutateRow(tableName, row, columnCheck, valueCheck, mutations, attributes);
      }
    }
  }

  bool checkAndMutateRowTs(const Text& tableName, const Text& row, const Text& columnCheck, const Text& valueCheck, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->checkAndMutateRowTs(tableName, row, columnCheck, valueCheck, mutations, timestamp, attributes);
      } else {
        ifaces_[i]->checkAndMutateRowTs(tableName, row, columnCheck, valueCheck, mutations, timestamp, attributes);
      }
    }
  }

  int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->atomicIncrement(tableName, row, column, value);
      } else {
        ifaces_[i]->atomicIncrement(tableName, row, column, value);
      }
    }
  }

  void deleteAll(const Text& tableName, const Text& row, const Text& column) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteAll(tableName, row, column);
    }
  }

  void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteAllTs(tableName, row, column, timestamp);
    }
  }

  void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteAllRow(tableName, row, attributes);
    }
  }

  void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteAllRowTs(tableName, row, timestamp);
    }
  }

  void mutateRowsAsync(const Text& tableName, const std::vector<BatchMutation> & rowBatches) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->mutateRowsAsync(tableName, rowBatches);
    }
  }

  void mutateRowsTsAsync(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->mutateRowsTsAsync(tableName, rowBatches, timestamp);
    }
  }

  int64_t taoAssocPut(const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t id2, const int64_t id1Type, const int64_t id2Type, const int64_t timestamp, const AssocVisibility::type visibility, const bool update_count, const int64_t dataVersion, const Text& data, const Text& wormhole_comment) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->taoAssocPut(tableName, assocType, id1, id2, id1Type, id2Type, timestamp, visibility, update_count, dataVersion, data, wormhole_comment);
      } else {
        ifaces_[i]->taoAssocPut(tableName, assocType, id1, id2, id1Type, id2Type, timestamp, visibility, update_count, dataVersion, data, wormhole_comment);
      }
    }
  }

  int64_t taoAssocDelete(const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t id2, const AssocVisibility::type visibility, const bool update_count, const Text& wormhole_comment) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->taoAssocDelete(tableName, assocType, id1, id2, visibility, update_count, wormhole_comment);
      } else {
        ifaces_[i]->taoAssocDelete(tableName, assocType, id1, id2, visibility, update_count, wormhole_comment);
      }
    }
  }

  void taoAssocRangeGet(std::vector<TaoAssocGetResult> & _return, const Text& tableName, const int64_t assocType, const int64_t id1, const int64_t start_time, const int64_t end_time, const int64_t offset, const int64_t limit) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->taoAssocRangeGet(_return, tableName, assocType, id1, start_time, end_time, offset, limit);
        return;
      } else {
        ifaces_[i]->taoAssocRangeGet(_return, tableName, assocType, id1, start_time, end_time, offset, limit);
      }
    }
  }

  void taoAssocGet(std::vector<TaoAssocGetResult> & _return, const Text& tableName, const int64_t assocType, const int64_t id1, const std::vector<int64_t> & id2s) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->taoAssocGet(_return, tableName, assocType, id1, id2s);
        return;
      } else {
        ifaces_[i]->taoAssocGet(_return, tableName, assocType, id1, id2s);
      }
    }
  }

  int64_t taoAssocCount(const Text& tableName, const int64_t assocType, const int64_t id1) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->taoAssocCount(tableName, assocType, id1);
      } else {
        ifaces_[i]->taoAssocCount(tableName, assocType, id1);
      }
    }
  }

  ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithScan(tableName, scan);
      } else {
        ifaces_[i]->scannerOpenWithScan(tableName, scan);
      }
    }
  }

  ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpen(tableName, startRow, columns);
      } else {
        ifaces_[i]->scannerOpen(tableName, startRow, columns);
      }
    }
  }

  ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenTs(tableName, startRow, columns, timestamp);
      } else {
        ifaces_[i]->scannerOpenTs(tableName, startRow, columns, timestamp);
      }
    }
  }

  ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithPrefix(tableName, startAndPrefix, columns);
      } else {
        ifaces_[i]->scannerOpenWithPrefix(tableName, startAndPrefix, columns);
      }
    }
  }

  ScannerID scannerOpenWithPrefixTs(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithPrefixTs(tableName, startAndPrefix, columns, timestamp);
      } else {
        ifaces_[i]->scannerOpenWithPrefixTs(tableName, startAndPrefix, columns, timestamp);
      }
    }
  }

  ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithStop(tableName, startRow, stopRow, columns);
      } else {
        ifaces_[i]->scannerOpenWithStop(tableName, startRow, stopRow, columns);
      }
    }
  }

  ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp);
      } else {
        ifaces_[i]->scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp);
      }
    }
  }

  ScannerID scannerOpenWithColumnPrefix(const Text& tableName, const Text& ColumnPrefix) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithColumnPrefix(tableName, ColumnPrefix);
      } else {
        ifaces_[i]->scannerOpenWithColumnPrefix(tableName, ColumnPrefix);
      }
    }
  }

  ScannerID scannerOpenWithColumnPrefixTs(const Text& tableName, const Text& ColumnPrefix, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithColumnPrefixTs(tableName, ColumnPrefix, timestamp);
      } else {
        ifaces_[i]->scannerOpenWithColumnPrefixTs(tableName, ColumnPrefix, timestamp);
      }
    }
  }

  ScannerID scannerOpenWithStopAndColumnPrefix(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& ColumnPrefix) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithStopAndColumnPrefix(tableName, startRow, stopRow, ColumnPrefix);
      } else {
        ifaces_[i]->scannerOpenWithStopAndColumnPrefix(tableName, startRow, stopRow, ColumnPrefix);
      }
    }
  }

  ScannerID scannerOpenWithStopAndColumnPrefixTs(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& ColumnPrefix, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithStopAndColumnPrefixTs(tableName, startRow, stopRow, ColumnPrefix, timestamp);
      } else {
        ifaces_[i]->scannerOpenWithStopAndColumnPrefixTs(tableName, startRow, stopRow, ColumnPrefix, timestamp);
      }
    }
  }

  ScannerID scannerOpenWithMultipleColumnPrefixes(const Text& tableName, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithMultipleColumnPrefixes(tableName, families, columnPrefixes);
      } else {
        ifaces_[i]->scannerOpenWithMultipleColumnPrefixes(tableName, families, columnPrefixes);
      }
    }
  }

  ScannerID scannerOpenWithMultipleColumnPrefixesTs(const Text& tableName, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithMultipleColumnPrefixesTs(tableName, families, columnPrefixes, timestamp);
      } else {
        ifaces_[i]->scannerOpenWithMultipleColumnPrefixesTs(tableName, families, columnPrefixes, timestamp);
      }
    }
  }

  ScannerID scannerOpenWithStopAndMultipleColumnPrefixes(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithStopAndMultipleColumnPrefixes(tableName, startRow, stopRow, families, columnPrefixes);
      } else {
        ifaces_[i]->scannerOpenWithStopAndMultipleColumnPrefixes(tableName, startRow, stopRow, families, columnPrefixes);
      }
    }
  }

  ScannerID scannerOpenWithStopAndMultipleColumnPrefixesTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & families, const std::vector<Text> & columnPrefixes, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithStopAndMultipleColumnPrefixesTs(tableName, startRow, stopRow, families, columnPrefixes, timestamp);
      } else {
        ifaces_[i]->scannerOpenWithStopAndMultipleColumnPrefixesTs(tableName, startRow, stopRow, families, columnPrefixes, timestamp);
      }
    }
  }

  void scannerGet(std::vector<TRowResult> & _return, const ScannerID id) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->scannerGet(_return, id);
        return;
      } else {
        ifaces_[i]->scannerGet(_return, id);
      }
    }
  }

  void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->scannerGetList(_return, id, nbRows);
        return;
      } else {
        ifaces_[i]->scannerGetList(_return, id, nbRows);
      }
    }
  }

  void scannerClose(const ScannerID id) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->scannerClose(id);
    }
  }

  void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowOrBefore(_return, tableName, row, family);
        return;
      } else {
        ifaces_[i]->getRowOrBefore(_return, tableName, row, family);
      }
    }
  }

  void getRegionInfo(TRegionInfo& _return, const Text& row) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRegionInfo(_return, row);
        return;
      } else {
        ifaces_[i]->getRegionInfo(_return, row);
      }
    }
  }

  ScannerID scannerOpenWithFilterString(const Text& tableName, const Text& filterString) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithFilterString(tableName, filterString);
      } else {
        ifaces_[i]->scannerOpenWithFilterString(tableName, filterString);
      }
    }
  }

  ScannerID scannerOpenWithFilterStringTs(const Text& tableName, const Text& filterString, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithFilterStringTs(tableName, filterString, timestamp);
      } else {
        ifaces_[i]->scannerOpenWithFilterStringTs(tableName, filterString, timestamp);
      }
    }
  }

  ScannerID scannerOpenWithStopAndFilterString(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& filterString) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithStopAndFilterString(tableName, startRow, stopRow, filterString);
      } else {
        ifaces_[i]->scannerOpenWithStopAndFilterString(tableName, startRow, stopRow, filterString);
      }
    }
  }

  ScannerID scannerOpenWithStopAndFilterStringTs(const Text& tableName, const Text& startRow, const Text& stopRow, const Text& filterString, const int64_t timestamp) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithStopAndFilterStringTs(tableName, startRow, stopRow, filterString, timestamp);
      } else {
        ifaces_[i]->scannerOpenWithStopAndFilterStringTs(tableName, startRow, stopRow, filterString, timestamp);
      }
    }
  }

};

}}}} // namespace

#endif
