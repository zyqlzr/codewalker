// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: topology.proto

#ifndef PROTOBUF_topology_2eproto__INCLUDED
#define PROTOBUF_topology_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace hummer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_topology_2eproto();
void protobuf_AssignDesc_topology_2eproto();
void protobuf_ShutdownFile_topology_2eproto();

class queue_def;
class db_def;
class io_def;
class node;
class topology;

// ===================================================================

class queue_def : public ::google::protobuf::Message {
 public:
  queue_def();
  virtual ~queue_def();

  queue_def(const queue_def& from);

  inline queue_def& operator=(const queue_def& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const queue_def& default_instance();

  void Swap(queue_def* other);

  // implements Message ----------------------------------------------

  queue_def* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const queue_def& from);
  void MergeFrom(const queue_def& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string host = 1;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 1;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional uint32 mqType = 2;
  inline bool has_mqtype() const;
  inline void clear_mqtype();
  static const int kMqTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 mqtype() const;
  inline void set_mqtype(::google::protobuf::uint32 value);

  // optional bool useFlag = 3;
  inline bool has_useflag() const;
  inline void clear_useflag();
  static const int kUseFlagFieldNumber = 3;
  inline bool useflag() const;
  inline void set_useflag(bool value);

  // optional bool ackFlag = 4;
  inline bool has_ackflag() const;
  inline void clear_ackflag();
  static const int kAckFlagFieldNumber = 4;
  inline bool ackflag() const;
  inline void set_ackflag(bool value);

  // optional string topic = 5;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 5;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional string queue = 6;
  inline bool has_queue() const;
  inline void clear_queue();
  static const int kQueueFieldNumber = 6;
  inline const ::std::string& queue() const;
  inline void set_queue(const ::std::string& value);
  inline void set_queue(const char* value);
  inline void set_queue(const char* value, size_t size);
  inline ::std::string* mutable_queue();
  inline ::std::string* release_queue();
  inline void set_allocated_queue(::std::string* queue);

  // @@protoc_insertion_point(class_scope:hummer.queue_def)
 private:
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_mqtype();
  inline void clear_has_mqtype();
  inline void set_has_useflag();
  inline void clear_has_useflag();
  inline void set_has_ackflag();
  inline void clear_has_ackflag();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_queue();
  inline void clear_has_queue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* host_;
  ::google::protobuf::uint32 mqtype_;
  bool useflag_;
  bool ackflag_;
  ::std::string* topic_;
  ::std::string* queue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_topology_2eproto();
  friend void protobuf_AssignDesc_topology_2eproto();
  friend void protobuf_ShutdownFile_topology_2eproto();

  void InitAsDefaultInstance();
  static queue_def* default_instance_;
};
// -------------------------------------------------------------------

class db_def : public ::google::protobuf::Message {
 public:
  db_def();
  virtual ~db_def();

  db_def(const db_def& from);

  inline db_def& operator=(const db_def& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const db_def& default_instance();

  void Swap(db_def* other);

  // implements Message ----------------------------------------------

  db_def* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const db_def& from);
  void MergeFrom(const db_def& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 dbtype = 1;
  inline bool has_dbtype() const;
  inline void clear_dbtype();
  static const int kDbtypeFieldNumber = 1;
  inline ::google::protobuf::uint32 dbtype() const;
  inline void set_dbtype(::google::protobuf::uint32 value);

  // optional string dbhost = 2;
  inline bool has_dbhost() const;
  inline void clear_dbhost();
  static const int kDbhostFieldNumber = 2;
  inline const ::std::string& dbhost() const;
  inline void set_dbhost(const ::std::string& value);
  inline void set_dbhost(const char* value);
  inline void set_dbhost(const char* value, size_t size);
  inline ::std::string* mutable_dbhost();
  inline ::std::string* release_dbhost();
  inline void set_allocated_dbhost(::std::string* dbhost);

  // optional string dbusr = 3;
  inline bool has_dbusr() const;
  inline void clear_dbusr();
  static const int kDbusrFieldNumber = 3;
  inline const ::std::string& dbusr() const;
  inline void set_dbusr(const ::std::string& value);
  inline void set_dbusr(const char* value);
  inline void set_dbusr(const char* value, size_t size);
  inline ::std::string* mutable_dbusr();
  inline ::std::string* release_dbusr();
  inline void set_allocated_dbusr(::std::string* dbusr);

  // optional string dbpw = 4;
  inline bool has_dbpw() const;
  inline void clear_dbpw();
  static const int kDbpwFieldNumber = 4;
  inline const ::std::string& dbpw() const;
  inline void set_dbpw(const ::std::string& value);
  inline void set_dbpw(const char* value);
  inline void set_dbpw(const char* value, size_t size);
  inline ::std::string* mutable_dbpw();
  inline ::std::string* release_dbpw();
  inline void set_allocated_dbpw(::std::string* dbpw);

  // optional uint32 dbport = 5;
  inline bool has_dbport() const;
  inline void clear_dbport();
  static const int kDbportFieldNumber = 5;
  inline ::google::protobuf::uint32 dbport() const;
  inline void set_dbport(::google::protobuf::uint32 value);

  // optional string dbname = 6;
  inline bool has_dbname() const;
  inline void clear_dbname();
  static const int kDbnameFieldNumber = 6;
  inline const ::std::string& dbname() const;
  inline void set_dbname(const ::std::string& value);
  inline void set_dbname(const char* value);
  inline void set_dbname(const char* value, size_t size);
  inline ::std::string* mutable_dbname();
  inline ::std::string* release_dbname();
  inline void set_allocated_dbname(::std::string* dbname);

  // repeated string tablename = 7;
  inline int tablename_size() const;
  inline void clear_tablename();
  static const int kTablenameFieldNumber = 7;
  inline const ::std::string& tablename(int index) const;
  inline ::std::string* mutable_tablename(int index);
  inline void set_tablename(int index, const ::std::string& value);
  inline void set_tablename(int index, const char* value);
  inline void set_tablename(int index, const char* value, size_t size);
  inline ::std::string* add_tablename();
  inline void add_tablename(const ::std::string& value);
  inline void add_tablename(const char* value);
  inline void add_tablename(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tablename() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tablename();

  // optional string mysqlUnixSock = 8;
  inline bool has_mysqlunixsock() const;
  inline void clear_mysqlunixsock();
  static const int kMysqlUnixSockFieldNumber = 8;
  inline const ::std::string& mysqlunixsock() const;
  inline void set_mysqlunixsock(const ::std::string& value);
  inline void set_mysqlunixsock(const char* value);
  inline void set_mysqlunixsock(const char* value, size_t size);
  inline ::std::string* mutable_mysqlunixsock();
  inline ::std::string* release_mysqlunixsock();
  inline void set_allocated_mysqlunixsock(::std::string* mysqlunixsock);

  // @@protoc_insertion_point(class_scope:hummer.db_def)
 private:
  inline void set_has_dbtype();
  inline void clear_has_dbtype();
  inline void set_has_dbhost();
  inline void clear_has_dbhost();
  inline void set_has_dbusr();
  inline void clear_has_dbusr();
  inline void set_has_dbpw();
  inline void clear_has_dbpw();
  inline void set_has_dbport();
  inline void clear_has_dbport();
  inline void set_has_dbname();
  inline void clear_has_dbname();
  inline void set_has_mysqlunixsock();
  inline void clear_has_mysqlunixsock();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dbhost_;
  ::std::string* dbusr_;
  ::google::protobuf::uint32 dbtype_;
  ::google::protobuf::uint32 dbport_;
  ::std::string* dbpw_;
  ::std::string* dbname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tablename_;
  ::std::string* mysqlunixsock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_topology_2eproto();
  friend void protobuf_AssignDesc_topology_2eproto();
  friend void protobuf_ShutdownFile_topology_2eproto();

  void InitAsDefaultInstance();
  static db_def* default_instance_;
};
// -------------------------------------------------------------------

class io_def : public ::google::protobuf::Message {
 public:
  io_def();
  virtual ~io_def();

  io_def(const io_def& from);

  inline io_def& operator=(const io_def& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const io_def& default_instance();

  void Swap(io_def* other);

  // implements Message ----------------------------------------------

  io_def* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const io_def& from);
  void MergeFrom(const io_def& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ioType = 1;
  inline bool has_iotype() const;
  inline void clear_iotype();
  static const int kIoTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 iotype() const;
  inline void set_iotype(::google::protobuf::uint32 value);

  // optional .hummer.db_def ioDB = 2;
  inline bool has_iodb() const;
  inline void clear_iodb();
  static const int kIoDBFieldNumber = 2;
  inline const ::hummer::db_def& iodb() const;
  inline ::hummer::db_def* mutable_iodb();
  inline ::hummer::db_def* release_iodb();
  inline void set_allocated_iodb(::hummer::db_def* iodb);

  // optional .hummer.queue_def ioQ = 3;
  inline bool has_ioq() const;
  inline void clear_ioq();
  static const int kIoQFieldNumber = 3;
  inline const ::hummer::queue_def& ioq() const;
  inline ::hummer::queue_def* mutable_ioq();
  inline ::hummer::queue_def* release_ioq();
  inline void set_allocated_ioq(::hummer::queue_def* ioq);

  // optional string ioZmqhost = 4;
  inline bool has_iozmqhost() const;
  inline void clear_iozmqhost();
  static const int kIoZmqhostFieldNumber = 4;
  inline const ::std::string& iozmqhost() const;
  inline void set_iozmqhost(const ::std::string& value);
  inline void set_iozmqhost(const char* value);
  inline void set_iozmqhost(const char* value, size_t size);
  inline ::std::string* mutable_iozmqhost();
  inline ::std::string* release_iozmqhost();
  inline void set_allocated_iozmqhost(::std::string* iozmqhost);

  // @@protoc_insertion_point(class_scope:hummer.io_def)
 private:
  inline void set_has_iotype();
  inline void clear_has_iotype();
  inline void set_has_iodb();
  inline void clear_has_iodb();
  inline void set_has_ioq();
  inline void clear_has_ioq();
  inline void set_has_iozmqhost();
  inline void clear_has_iozmqhost();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::hummer::db_def* iodb_;
  ::hummer::queue_def* ioq_;
  ::std::string* iozmqhost_;
  ::google::protobuf::uint32 iotype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_topology_2eproto();
  friend void protobuf_AssignDesc_topology_2eproto();
  friend void protobuf_ShutdownFile_topology_2eproto();

  void InitAsDefaultInstance();
  static io_def* default_instance_;
};
// -------------------------------------------------------------------

class node : public ::google::protobuf::Message {
 public:
  node();
  virtual ~node();

  node(const node& from);

  inline node& operator=(const node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const node& default_instance();

  void Swap(node* other);

  // implements Message ----------------------------------------------

  node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const node& from);
  void MergeFrom(const node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string serverDes = 1;
  inline bool has_serverdes() const;
  inline void clear_serverdes();
  static const int kServerDesFieldNumber = 1;
  inline const ::std::string& serverdes() const;
  inline void set_serverdes(const ::std::string& value);
  inline void set_serverdes(const char* value);
  inline void set_serverdes(const char* value, size_t size);
  inline ::std::string* mutable_serverdes();
  inline ::std::string* release_serverdes();
  inline void set_allocated_serverdes(::std::string* serverdes);

  // required uint32 nodeType = 2;
  inline bool has_nodetype() const;
  inline void clear_nodetype();
  static const int kNodeTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 nodetype() const;
  inline void set_nodetype(::google::protobuf::uint32 value);

  // repeated .hummer.io_def inputs = 3;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 3;
  inline const ::hummer::io_def& inputs(int index) const;
  inline ::hummer::io_def* mutable_inputs(int index);
  inline ::hummer::io_def* add_inputs();
  inline const ::google::protobuf::RepeatedPtrField< ::hummer::io_def >&
      inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::hummer::io_def >*
      mutable_inputs();

  // repeated .hummer.io_def outputs = 4;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 4;
  inline const ::hummer::io_def& outputs(int index) const;
  inline ::hummer::io_def* mutable_outputs(int index);
  inline ::hummer::io_def* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::hummer::io_def >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::hummer::io_def >*
      mutable_outputs();

  // @@protoc_insertion_point(class_scope:hummer.node)
 private:
  inline void set_has_serverdes();
  inline void clear_has_serverdes();
  inline void set_has_nodetype();
  inline void clear_has_nodetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* serverdes_;
  ::google::protobuf::RepeatedPtrField< ::hummer::io_def > inputs_;
  ::google::protobuf::RepeatedPtrField< ::hummer::io_def > outputs_;
  ::google::protobuf::uint32 nodetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_topology_2eproto();
  friend void protobuf_AssignDesc_topology_2eproto();
  friend void protobuf_ShutdownFile_topology_2eproto();

  void InitAsDefaultInstance();
  static node* default_instance_;
};
// -------------------------------------------------------------------

class topology : public ::google::protobuf::Message {
 public:
  topology();
  virtual ~topology();

  topology(const topology& from);

  inline topology& operator=(const topology& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const topology& default_instance();

  void Swap(topology* other);

  // implements Message ----------------------------------------------

  topology* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const topology& from);
  void MergeFrom(const topology& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 topologyId = 1;
  inline bool has_topologyid() const;
  inline void clear_topologyid();
  static const int kTopologyIdFieldNumber = 1;
  inline ::google::protobuf::uint64 topologyid() const;
  inline void set_topologyid(::google::protobuf::uint64 value);

  // repeated .hummer.node nodes = 2;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 2;
  inline const ::hummer::node& nodes(int index) const;
  inline ::hummer::node* mutable_nodes(int index);
  inline ::hummer::node* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::hummer::node >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::hummer::node >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:hummer.topology)
 private:
  inline void set_has_topologyid();
  inline void clear_has_topologyid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 topologyid_;
  ::google::protobuf::RepeatedPtrField< ::hummer::node > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_topology_2eproto();
  friend void protobuf_AssignDesc_topology_2eproto();
  friend void protobuf_ShutdownFile_topology_2eproto();

  void InitAsDefaultInstance();
  static topology* default_instance_;
};
// ===================================================================


// ===================================================================

// queue_def

// optional string host = 1;
inline bool queue_def::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void queue_def::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void queue_def::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void queue_def::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& queue_def::host() const {
  return *host_;
}
inline void queue_def::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void queue_def::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void queue_def::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* queue_def::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* queue_def::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void queue_def::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 mqType = 2;
inline bool queue_def::has_mqtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void queue_def::set_has_mqtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void queue_def::clear_has_mqtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void queue_def::clear_mqtype() {
  mqtype_ = 0u;
  clear_has_mqtype();
}
inline ::google::protobuf::uint32 queue_def::mqtype() const {
  return mqtype_;
}
inline void queue_def::set_mqtype(::google::protobuf::uint32 value) {
  set_has_mqtype();
  mqtype_ = value;
}

// optional bool useFlag = 3;
inline bool queue_def::has_useflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void queue_def::set_has_useflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void queue_def::clear_has_useflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void queue_def::clear_useflag() {
  useflag_ = false;
  clear_has_useflag();
}
inline bool queue_def::useflag() const {
  return useflag_;
}
inline void queue_def::set_useflag(bool value) {
  set_has_useflag();
  useflag_ = value;
}

// optional bool ackFlag = 4;
inline bool queue_def::has_ackflag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void queue_def::set_has_ackflag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void queue_def::clear_has_ackflag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void queue_def::clear_ackflag() {
  ackflag_ = false;
  clear_has_ackflag();
}
inline bool queue_def::ackflag() const {
  return ackflag_;
}
inline void queue_def::set_ackflag(bool value) {
  set_has_ackflag();
  ackflag_ = value;
}

// optional string topic = 5;
inline bool queue_def::has_topic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void queue_def::set_has_topic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void queue_def::clear_has_topic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void queue_def::clear_topic() {
  if (topic_ != &::google::protobuf::internal::kEmptyString) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& queue_def::topic() const {
  return *topic_;
}
inline void queue_def::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void queue_def::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void queue_def::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* queue_def::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  return topic_;
}
inline ::std::string* queue_def::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void queue_def::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::kEmptyString) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string queue = 6;
inline bool queue_def::has_queue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void queue_def::set_has_queue() {
  _has_bits_[0] |= 0x00000020u;
}
inline void queue_def::clear_has_queue() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void queue_def::clear_queue() {
  if (queue_ != &::google::protobuf::internal::kEmptyString) {
    queue_->clear();
  }
  clear_has_queue();
}
inline const ::std::string& queue_def::queue() const {
  return *queue_;
}
inline void queue_def::set_queue(const ::std::string& value) {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  queue_->assign(value);
}
inline void queue_def::set_queue(const char* value) {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  queue_->assign(value);
}
inline void queue_def::set_queue(const char* value, size_t size) {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  queue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* queue_def::mutable_queue() {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  return queue_;
}
inline ::std::string* queue_def::release_queue() {
  clear_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = queue_;
    queue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void queue_def::set_allocated_queue(::std::string* queue) {
  if (queue_ != &::google::protobuf::internal::kEmptyString) {
    delete queue_;
  }
  if (queue) {
    set_has_queue();
    queue_ = queue;
  } else {
    clear_has_queue();
    queue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// db_def

// optional uint32 dbtype = 1;
inline bool db_def::has_dbtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void db_def::set_has_dbtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void db_def::clear_has_dbtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void db_def::clear_dbtype() {
  dbtype_ = 0u;
  clear_has_dbtype();
}
inline ::google::protobuf::uint32 db_def::dbtype() const {
  return dbtype_;
}
inline void db_def::set_dbtype(::google::protobuf::uint32 value) {
  set_has_dbtype();
  dbtype_ = value;
}

// optional string dbhost = 2;
inline bool db_def::has_dbhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void db_def::set_has_dbhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void db_def::clear_has_dbhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void db_def::clear_dbhost() {
  if (dbhost_ != &::google::protobuf::internal::kEmptyString) {
    dbhost_->clear();
  }
  clear_has_dbhost();
}
inline const ::std::string& db_def::dbhost() const {
  return *dbhost_;
}
inline void db_def::set_dbhost(const ::std::string& value) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(value);
}
inline void db_def::set_dbhost(const char* value) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(value);
}
inline void db_def::set_dbhost(const char* value, size_t size) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* db_def::mutable_dbhost() {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  return dbhost_;
}
inline ::std::string* db_def::release_dbhost() {
  clear_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbhost_;
    dbhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void db_def::set_allocated_dbhost(::std::string* dbhost) {
  if (dbhost_ != &::google::protobuf::internal::kEmptyString) {
    delete dbhost_;
  }
  if (dbhost) {
    set_has_dbhost();
    dbhost_ = dbhost;
  } else {
    clear_has_dbhost();
    dbhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbusr = 3;
inline bool db_def::has_dbusr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void db_def::set_has_dbusr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void db_def::clear_has_dbusr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void db_def::clear_dbusr() {
  if (dbusr_ != &::google::protobuf::internal::kEmptyString) {
    dbusr_->clear();
  }
  clear_has_dbusr();
}
inline const ::std::string& db_def::dbusr() const {
  return *dbusr_;
}
inline void db_def::set_dbusr(const ::std::string& value) {
  set_has_dbusr();
  if (dbusr_ == &::google::protobuf::internal::kEmptyString) {
    dbusr_ = new ::std::string;
  }
  dbusr_->assign(value);
}
inline void db_def::set_dbusr(const char* value) {
  set_has_dbusr();
  if (dbusr_ == &::google::protobuf::internal::kEmptyString) {
    dbusr_ = new ::std::string;
  }
  dbusr_->assign(value);
}
inline void db_def::set_dbusr(const char* value, size_t size) {
  set_has_dbusr();
  if (dbusr_ == &::google::protobuf::internal::kEmptyString) {
    dbusr_ = new ::std::string;
  }
  dbusr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* db_def::mutable_dbusr() {
  set_has_dbusr();
  if (dbusr_ == &::google::protobuf::internal::kEmptyString) {
    dbusr_ = new ::std::string;
  }
  return dbusr_;
}
inline ::std::string* db_def::release_dbusr() {
  clear_has_dbusr();
  if (dbusr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbusr_;
    dbusr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void db_def::set_allocated_dbusr(::std::string* dbusr) {
  if (dbusr_ != &::google::protobuf::internal::kEmptyString) {
    delete dbusr_;
  }
  if (dbusr) {
    set_has_dbusr();
    dbusr_ = dbusr;
  } else {
    clear_has_dbusr();
    dbusr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbpw = 4;
inline bool db_def::has_dbpw() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void db_def::set_has_dbpw() {
  _has_bits_[0] |= 0x00000008u;
}
inline void db_def::clear_has_dbpw() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void db_def::clear_dbpw() {
  if (dbpw_ != &::google::protobuf::internal::kEmptyString) {
    dbpw_->clear();
  }
  clear_has_dbpw();
}
inline const ::std::string& db_def::dbpw() const {
  return *dbpw_;
}
inline void db_def::set_dbpw(const ::std::string& value) {
  set_has_dbpw();
  if (dbpw_ == &::google::protobuf::internal::kEmptyString) {
    dbpw_ = new ::std::string;
  }
  dbpw_->assign(value);
}
inline void db_def::set_dbpw(const char* value) {
  set_has_dbpw();
  if (dbpw_ == &::google::protobuf::internal::kEmptyString) {
    dbpw_ = new ::std::string;
  }
  dbpw_->assign(value);
}
inline void db_def::set_dbpw(const char* value, size_t size) {
  set_has_dbpw();
  if (dbpw_ == &::google::protobuf::internal::kEmptyString) {
    dbpw_ = new ::std::string;
  }
  dbpw_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* db_def::mutable_dbpw() {
  set_has_dbpw();
  if (dbpw_ == &::google::protobuf::internal::kEmptyString) {
    dbpw_ = new ::std::string;
  }
  return dbpw_;
}
inline ::std::string* db_def::release_dbpw() {
  clear_has_dbpw();
  if (dbpw_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbpw_;
    dbpw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void db_def::set_allocated_dbpw(::std::string* dbpw) {
  if (dbpw_ != &::google::protobuf::internal::kEmptyString) {
    delete dbpw_;
  }
  if (dbpw) {
    set_has_dbpw();
    dbpw_ = dbpw;
  } else {
    clear_has_dbpw();
    dbpw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 dbport = 5;
inline bool db_def::has_dbport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void db_def::set_has_dbport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void db_def::clear_has_dbport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void db_def::clear_dbport() {
  dbport_ = 0u;
  clear_has_dbport();
}
inline ::google::protobuf::uint32 db_def::dbport() const {
  return dbport_;
}
inline void db_def::set_dbport(::google::protobuf::uint32 value) {
  set_has_dbport();
  dbport_ = value;
}

// optional string dbname = 6;
inline bool db_def::has_dbname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void db_def::set_has_dbname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void db_def::clear_has_dbname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void db_def::clear_dbname() {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    dbname_->clear();
  }
  clear_has_dbname();
}
inline const ::std::string& db_def::dbname() const {
  return *dbname_;
}
inline void db_def::set_dbname(const ::std::string& value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void db_def::set_dbname(const char* value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void db_def::set_dbname(const char* value, size_t size) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* db_def::mutable_dbname() {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  return dbname_;
}
inline ::std::string* db_def::release_dbname() {
  clear_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbname_;
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void db_def::set_allocated_dbname(::std::string* dbname) {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    delete dbname_;
  }
  if (dbname) {
    set_has_dbname();
    dbname_ = dbname;
  } else {
    clear_has_dbname();
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string tablename = 7;
inline int db_def::tablename_size() const {
  return tablename_.size();
}
inline void db_def::clear_tablename() {
  tablename_.Clear();
}
inline const ::std::string& db_def::tablename(int index) const {
  return tablename_.Get(index);
}
inline ::std::string* db_def::mutable_tablename(int index) {
  return tablename_.Mutable(index);
}
inline void db_def::set_tablename(int index, const ::std::string& value) {
  tablename_.Mutable(index)->assign(value);
}
inline void db_def::set_tablename(int index, const char* value) {
  tablename_.Mutable(index)->assign(value);
}
inline void db_def::set_tablename(int index, const char* value, size_t size) {
  tablename_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* db_def::add_tablename() {
  return tablename_.Add();
}
inline void db_def::add_tablename(const ::std::string& value) {
  tablename_.Add()->assign(value);
}
inline void db_def::add_tablename(const char* value) {
  tablename_.Add()->assign(value);
}
inline void db_def::add_tablename(const char* value, size_t size) {
  tablename_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
db_def::tablename() const {
  return tablename_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
db_def::mutable_tablename() {
  return &tablename_;
}

// optional string mysqlUnixSock = 8;
inline bool db_def::has_mysqlunixsock() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void db_def::set_has_mysqlunixsock() {
  _has_bits_[0] |= 0x00000080u;
}
inline void db_def::clear_has_mysqlunixsock() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void db_def::clear_mysqlunixsock() {
  if (mysqlunixsock_ != &::google::protobuf::internal::kEmptyString) {
    mysqlunixsock_->clear();
  }
  clear_has_mysqlunixsock();
}
inline const ::std::string& db_def::mysqlunixsock() const {
  return *mysqlunixsock_;
}
inline void db_def::set_mysqlunixsock(const ::std::string& value) {
  set_has_mysqlunixsock();
  if (mysqlunixsock_ == &::google::protobuf::internal::kEmptyString) {
    mysqlunixsock_ = new ::std::string;
  }
  mysqlunixsock_->assign(value);
}
inline void db_def::set_mysqlunixsock(const char* value) {
  set_has_mysqlunixsock();
  if (mysqlunixsock_ == &::google::protobuf::internal::kEmptyString) {
    mysqlunixsock_ = new ::std::string;
  }
  mysqlunixsock_->assign(value);
}
inline void db_def::set_mysqlunixsock(const char* value, size_t size) {
  set_has_mysqlunixsock();
  if (mysqlunixsock_ == &::google::protobuf::internal::kEmptyString) {
    mysqlunixsock_ = new ::std::string;
  }
  mysqlunixsock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* db_def::mutable_mysqlunixsock() {
  set_has_mysqlunixsock();
  if (mysqlunixsock_ == &::google::protobuf::internal::kEmptyString) {
    mysqlunixsock_ = new ::std::string;
  }
  return mysqlunixsock_;
}
inline ::std::string* db_def::release_mysqlunixsock() {
  clear_has_mysqlunixsock();
  if (mysqlunixsock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqlunixsock_;
    mysqlunixsock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void db_def::set_allocated_mysqlunixsock(::std::string* mysqlunixsock) {
  if (mysqlunixsock_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqlunixsock_;
  }
  if (mysqlunixsock) {
    set_has_mysqlunixsock();
    mysqlunixsock_ = mysqlunixsock;
  } else {
    clear_has_mysqlunixsock();
    mysqlunixsock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// io_def

// required uint32 ioType = 1;
inline bool io_def::has_iotype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void io_def::set_has_iotype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void io_def::clear_has_iotype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void io_def::clear_iotype() {
  iotype_ = 0u;
  clear_has_iotype();
}
inline ::google::protobuf::uint32 io_def::iotype() const {
  return iotype_;
}
inline void io_def::set_iotype(::google::protobuf::uint32 value) {
  set_has_iotype();
  iotype_ = value;
}

// optional .hummer.db_def ioDB = 2;
inline bool io_def::has_iodb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void io_def::set_has_iodb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void io_def::clear_has_iodb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void io_def::clear_iodb() {
  if (iodb_ != NULL) iodb_->::hummer::db_def::Clear();
  clear_has_iodb();
}
inline const ::hummer::db_def& io_def::iodb() const {
  return iodb_ != NULL ? *iodb_ : *default_instance_->iodb_;
}
inline ::hummer::db_def* io_def::mutable_iodb() {
  set_has_iodb();
  if (iodb_ == NULL) iodb_ = new ::hummer::db_def;
  return iodb_;
}
inline ::hummer::db_def* io_def::release_iodb() {
  clear_has_iodb();
  ::hummer::db_def* temp = iodb_;
  iodb_ = NULL;
  return temp;
}
inline void io_def::set_allocated_iodb(::hummer::db_def* iodb) {
  delete iodb_;
  iodb_ = iodb;
  if (iodb) {
    set_has_iodb();
  } else {
    clear_has_iodb();
  }
}

// optional .hummer.queue_def ioQ = 3;
inline bool io_def::has_ioq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void io_def::set_has_ioq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void io_def::clear_has_ioq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void io_def::clear_ioq() {
  if (ioq_ != NULL) ioq_->::hummer::queue_def::Clear();
  clear_has_ioq();
}
inline const ::hummer::queue_def& io_def::ioq() const {
  return ioq_ != NULL ? *ioq_ : *default_instance_->ioq_;
}
inline ::hummer::queue_def* io_def::mutable_ioq() {
  set_has_ioq();
  if (ioq_ == NULL) ioq_ = new ::hummer::queue_def;
  return ioq_;
}
inline ::hummer::queue_def* io_def::release_ioq() {
  clear_has_ioq();
  ::hummer::queue_def* temp = ioq_;
  ioq_ = NULL;
  return temp;
}
inline void io_def::set_allocated_ioq(::hummer::queue_def* ioq) {
  delete ioq_;
  ioq_ = ioq;
  if (ioq) {
    set_has_ioq();
  } else {
    clear_has_ioq();
  }
}

// optional string ioZmqhost = 4;
inline bool io_def::has_iozmqhost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void io_def::set_has_iozmqhost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void io_def::clear_has_iozmqhost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void io_def::clear_iozmqhost() {
  if (iozmqhost_ != &::google::protobuf::internal::kEmptyString) {
    iozmqhost_->clear();
  }
  clear_has_iozmqhost();
}
inline const ::std::string& io_def::iozmqhost() const {
  return *iozmqhost_;
}
inline void io_def::set_iozmqhost(const ::std::string& value) {
  set_has_iozmqhost();
  if (iozmqhost_ == &::google::protobuf::internal::kEmptyString) {
    iozmqhost_ = new ::std::string;
  }
  iozmqhost_->assign(value);
}
inline void io_def::set_iozmqhost(const char* value) {
  set_has_iozmqhost();
  if (iozmqhost_ == &::google::protobuf::internal::kEmptyString) {
    iozmqhost_ = new ::std::string;
  }
  iozmqhost_->assign(value);
}
inline void io_def::set_iozmqhost(const char* value, size_t size) {
  set_has_iozmqhost();
  if (iozmqhost_ == &::google::protobuf::internal::kEmptyString) {
    iozmqhost_ = new ::std::string;
  }
  iozmqhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* io_def::mutable_iozmqhost() {
  set_has_iozmqhost();
  if (iozmqhost_ == &::google::protobuf::internal::kEmptyString) {
    iozmqhost_ = new ::std::string;
  }
  return iozmqhost_;
}
inline ::std::string* io_def::release_iozmqhost() {
  clear_has_iozmqhost();
  if (iozmqhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iozmqhost_;
    iozmqhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void io_def::set_allocated_iozmqhost(::std::string* iozmqhost) {
  if (iozmqhost_ != &::google::protobuf::internal::kEmptyString) {
    delete iozmqhost_;
  }
  if (iozmqhost) {
    set_has_iozmqhost();
    iozmqhost_ = iozmqhost;
  } else {
    clear_has_iozmqhost();
    iozmqhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// node

// required string serverDes = 1;
inline bool node::has_serverdes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void node::set_has_serverdes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void node::clear_has_serverdes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void node::clear_serverdes() {
  if (serverdes_ != &::google::protobuf::internal::kEmptyString) {
    serverdes_->clear();
  }
  clear_has_serverdes();
}
inline const ::std::string& node::serverdes() const {
  return *serverdes_;
}
inline void node::set_serverdes(const ::std::string& value) {
  set_has_serverdes();
  if (serverdes_ == &::google::protobuf::internal::kEmptyString) {
    serverdes_ = new ::std::string;
  }
  serverdes_->assign(value);
}
inline void node::set_serverdes(const char* value) {
  set_has_serverdes();
  if (serverdes_ == &::google::protobuf::internal::kEmptyString) {
    serverdes_ = new ::std::string;
  }
  serverdes_->assign(value);
}
inline void node::set_serverdes(const char* value, size_t size) {
  set_has_serverdes();
  if (serverdes_ == &::google::protobuf::internal::kEmptyString) {
    serverdes_ = new ::std::string;
  }
  serverdes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* node::mutable_serverdes() {
  set_has_serverdes();
  if (serverdes_ == &::google::protobuf::internal::kEmptyString) {
    serverdes_ = new ::std::string;
  }
  return serverdes_;
}
inline ::std::string* node::release_serverdes() {
  clear_has_serverdes();
  if (serverdes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverdes_;
    serverdes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void node::set_allocated_serverdes(::std::string* serverdes) {
  if (serverdes_ != &::google::protobuf::internal::kEmptyString) {
    delete serverdes_;
  }
  if (serverdes) {
    set_has_serverdes();
    serverdes_ = serverdes;
  } else {
    clear_has_serverdes();
    serverdes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 nodeType = 2;
inline bool node::has_nodetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void node::set_has_nodetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void node::clear_has_nodetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void node::clear_nodetype() {
  nodetype_ = 0u;
  clear_has_nodetype();
}
inline ::google::protobuf::uint32 node::nodetype() const {
  return nodetype_;
}
inline void node::set_nodetype(::google::protobuf::uint32 value) {
  set_has_nodetype();
  nodetype_ = value;
}

// repeated .hummer.io_def inputs = 3;
inline int node::inputs_size() const {
  return inputs_.size();
}
inline void node::clear_inputs() {
  inputs_.Clear();
}
inline const ::hummer::io_def& node::inputs(int index) const {
  return inputs_.Get(index);
}
inline ::hummer::io_def* node::mutable_inputs(int index) {
  return inputs_.Mutable(index);
}
inline ::hummer::io_def* node::add_inputs() {
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hummer::io_def >&
node::inputs() const {
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::hummer::io_def >*
node::mutable_inputs() {
  return &inputs_;
}

// repeated .hummer.io_def outputs = 4;
inline int node::outputs_size() const {
  return outputs_.size();
}
inline void node::clear_outputs() {
  outputs_.Clear();
}
inline const ::hummer::io_def& node::outputs(int index) const {
  return outputs_.Get(index);
}
inline ::hummer::io_def* node::mutable_outputs(int index) {
  return outputs_.Mutable(index);
}
inline ::hummer::io_def* node::add_outputs() {
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hummer::io_def >&
node::outputs() const {
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::hummer::io_def >*
node::mutable_outputs() {
  return &outputs_;
}

// -------------------------------------------------------------------

// topology

// required uint64 topologyId = 1;
inline bool topology::has_topologyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void topology::set_has_topologyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void topology::clear_has_topologyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void topology::clear_topologyid() {
  topologyid_ = GOOGLE_ULONGLONG(0);
  clear_has_topologyid();
}
inline ::google::protobuf::uint64 topology::topologyid() const {
  return topologyid_;
}
inline void topology::set_topologyid(::google::protobuf::uint64 value) {
  set_has_topologyid();
  topologyid_ = value;
}

// repeated .hummer.node nodes = 2;
inline int topology::nodes_size() const {
  return nodes_.size();
}
inline void topology::clear_nodes() {
  nodes_.Clear();
}
inline const ::hummer::node& topology::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::hummer::node* topology::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::hummer::node* topology::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hummer::node >&
topology::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::hummer::node >*
topology::mutable_nodes() {
  return &nodes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace hummer

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_topology_2eproto__INCLUDED
